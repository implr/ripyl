
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>ripyl.protocol package &#8212; Ripyl 1.2.1 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="https://kevinpt.github.io/opbasm/_static/project.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.2.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link href='http://fonts.googleapis.com/css?family=Kreon:400,300,700' rel='stylesheet' type='text/css'>

   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="ripyl-protocol-package">
<h1>ripyl.protocol package<a class="headerlink" href="#ripyl-protocol-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="ripyl.protocol.infrared.html">ripyl.protocol.infrared package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.infrared.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.infrared.html#module-ripyl.protocol.infrared.ir_common">ripyl.protocol.infrared.ir_common module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.infrared.html#module-ripyl.protocol.infrared.nec">ripyl.protocol.infrared.nec module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.infrared.html#module-ripyl.protocol.infrared.rc5">ripyl.protocol.infrared.rc5 module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.infrared.html#module-ripyl.protocol.infrared.rc6">ripyl.protocol.infrared.rc6 module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.infrared.html#module-ripyl.protocol.infrared.sirc">ripyl.protocol.infrared.sirc module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.infrared.html#module-ripyl.protocol.infrared">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-ripyl.protocol.can">
<span id="ripyl-protocol-can-module"></span><h2>ripyl.protocol.can module<a class="headerlink" href="#module-ripyl.protocol.can" title="Permalink to this headline">¶</a></h2>
<p>CAN protocol decoder</p>
<dl class="exception">
<dt id="ripyl.protocol.can.AutoRateError">
<em class="property">exception </em><code class="descclassname">ripyl.protocol.can.</code><code class="descname">AutoRateError</code><a class="headerlink" href="#ripyl.protocol.can.AutoRateError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamError" title="ripyl.streaming.StreamError"><code class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamError</span></code></a></p>
<p>Error for failed bit rate detection</p>
</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.can.CANConfig">
<em class="property">class </em><code class="descclassname">ripyl.protocol.can.</code><code class="descname">CANConfig</code><a class="headerlink" href="#ripyl.protocol.can.CANConfig" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><code class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></code></a></p>
<p>Enumeration of configuration settings</p>
<dl class="attribute">
<dt id="ripyl.protocol.can.CANConfig.IdleHigh">
<code class="descname">IdleHigh</code><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.can.CANConfig.IdleHigh" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.can.CANConfig.IdleLow">
<code class="descname">IdleLow</code><em class="property"> = 2</em><a class="headerlink" href="#ripyl.protocol.can.CANConfig.IdleLow" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.can.CANErrorFrame">
<em class="property">class </em><code class="descclassname">ripyl.protocol.can.</code><code class="descname">CANErrorFrame</code><span class="sig-paren">(</span><em>flag_bits=6</em>, <em>ifs_bits=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.can.CANErrorFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>CAN Error frame</p>
<dl class="method">
<dt id="ripyl.protocol.can.CANErrorFrame.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>flag_bits=6</em>, <em>ifs_bits=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.can.CANErrorFrame.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ripyl.protocol.can.CANErrorFrame.get_edges">
<code class="descname">get_edges</code><span class="sig-paren">(</span><em>t</em>, <em>bit_period</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.can.CANErrorFrame.get_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an edge sequence for this frame</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>t</strong> (<em>float</em>) – Start time for the edges</li>
<li><strong>bit_period</strong> (<em>float</em>) – The period for each bit of the frame</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param  :
:returns: A list of 2-tuples representing each edge.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.can.CANExtendedFrame">
<em class="property">class </em><code class="descclassname">ripyl.protocol.can.</code><code class="descname">CANExtendedFrame</code><span class="sig-paren">(</span><em>full_id</em>, <em>data</em>, <em>dlc=None</em>, <em>crc=None</em>, <em>ack=True</em>, <em>trim_bits=0</em>, <em>ifs_bits=3</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.can.CANExtendedFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.protocol.can.CANFrame" title="ripyl.protocol.can.CANFrame"><code class="xref py py-class docutils literal"><span class="pre">ripyl.protocol.can.CANFrame</span></code></a></p>
<p>CAN frame format for 29-bit ID</p>
<dl class="method">
<dt id="ripyl.protocol.can.CANExtendedFrame.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>full_id</em>, <em>data</em>, <em>dlc=None</em>, <em>crc=None</em>, <em>ack=True</em>, <em>trim_bits=0</em>, <em>ifs_bits=3</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.can.CANExtendedFrame.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>full_id</strong> (<em>int</em>) – 29-bit CAN frame ID</li>
<li><strong>data</strong> (<em>sequence of int</em><em> or </em><em>None</em>) – Data bytes for a data frame. None or empty list for a remote frame.</li>
<li><strong>dlc</strong> (<em>int</em><em> or </em><em>None</em>) – The Data Length Code (number of data bytes) for the frame.</li>
<li><strong>crc</strong> (<em>int</em><em> or </em><em>None</em>) – The decoded CRC for the frame. Leave as None to generate CRC automatically.</li>
<li><strong>ack</strong> (<em>bool</em>) – Indicates that the ack field is dominant (True) or recessive (False).</li>
<li><strong>trim_bits</strong> (<em>int</em>) – The number of bits to trim off the end of the frame. Used to simulate error conditions.</li>
<li><strong>ifs_bits</strong> (<em>int</em>) – The number of Inter-Frame Space bits at the start of this frame. Normally 3.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.can.CANExtendedFrame.full_id">
<code class="descname">full_id</code><a class="headerlink" href="#ripyl.protocol.can.CANExtendedFrame.full_id" title="Permalink to this definition">¶</a></dt>
<dd><p>The full 29-bit ID for this frame</p>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.can.CANExtendedFrame.get_bits">
<code class="descname">get_bits</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.can.CANExtendedFrame.get_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate extended frame bits</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.can.CANFrame">
<em class="property">class </em><code class="descclassname">ripyl.protocol.can.</code><code class="descname">CANFrame</code><span class="sig-paren">(</span><em>id</em>, <em>data</em>, <em>dlc=None</em>, <em>crc=None</em>, <em>ack=True</em>, <em>trim_bits=0</em>, <em>ifs_bits=3</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.can.CANFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Base class for CAN Data and Remote frames</p>
<dl class="method">
<dt id="ripyl.protocol.can.CANFrame.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>id</em>, <em>data</em>, <em>dlc=None</em>, <em>crc=None</em>, <em>ack=True</em>, <em>trim_bits=0</em>, <em>ifs_bits=3</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.can.CANFrame.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>id</strong> (<em>int</em>) – CAN frame ID</li>
<li><strong>data</strong> (<em>sequence of int</em><em> or </em><em>None</em>) – Data bytes for a data frame. None or empty list for a remote frame.</li>
<li><strong>dlc</strong> (<em>int</em><em> or </em><em>None</em>) – The Data Length Code (number of data bytes) for the frame.</li>
<li><strong>crc</strong> (<em>int</em><em> or </em><em>None</em>) – The decoded CRC for the frame. Leave as None to generate CRC automatically.</li>
<li><strong>ack</strong> (<em>bool</em>) – Indicates that the ack field is dominant (True) or recessive (False).</li>
<li><strong>trim_bits</strong> (<em>int</em>) – The number of bits to trim off the end of the frame. Used to simulate error conditions.</li>
<li><strong>ifs_bits</strong> (<em>int</em>) – The number of Inter-Frame Space bits at the start of this frame. Normally 3.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.can.CANFrame.crc">
<code class="descname">crc</code><a class="headerlink" href="#ripyl.protocol.can.CANFrame.crc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ripyl.protocol.can.CANFrame.crc_is_valid">
<code class="descname">crc_is_valid</code><span class="sig-paren">(</span><em>recv_crc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.can.CANFrame.crc_is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a decoded CRC is valid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>recv_crc</strong> (<em>int</em><em> or </em><em>None</em>) – The decoded CRC to check against. If None, the CRC passed in the constructor is used.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True when the crc is correct.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.can.CANFrame.dlc">
<code class="descname">dlc</code><a class="headerlink" href="#ripyl.protocol.can.CANFrame.dlc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.can.CANFrame.full_id">
<code class="descname">full_id</code><a class="headerlink" href="#ripyl.protocol.can.CANFrame.full_id" title="Permalink to this definition">¶</a></dt>
<dd><p>The full 11-bit ID for this frame</p>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.can.CANFrame.get_bits">
<code class="descname">get_bits</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.can.CANFrame.get_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the raw bits for this frame</p>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.can.CANFrame.get_edges">
<code class="descname">get_edges</code><span class="sig-paren">(</span><em>t</em>, <em>bit_period</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.can.CANFrame.get_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an edge sequence for this frame</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>t</strong> (<em>float</em>) – Start time for the edges</li>
<li><strong>bit_period</strong> (<em>float</em>) – The period for each bit of the frame</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param  :
:returns: A list of 2-tuples representing each edge.</p>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.can.CANFrame.rtr">
<code class="descname">rtr</code><a class="headerlink" href="#ripyl.protocol.can.CANFrame.rtr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.can.CANOverloadFrame">
<em class="property">class </em><code class="descclassname">ripyl.protocol.can.</code><code class="descname">CANOverloadFrame</code><span class="sig-paren">(</span><em>flag_bits=6</em>, <em>ifs_bits=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.can.CANOverloadFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.protocol.can.CANErrorFrame" title="ripyl.protocol.can.CANErrorFrame"><code class="xref py py-class docutils literal"><span class="pre">ripyl.protocol.can.CANErrorFrame</span></code></a></p>
<p>CAN Overload frame</p>
<dl class="method">
<dt id="ripyl.protocol.can.CANOverloadFrame.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>flag_bits=6</em>, <em>ifs_bits=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.can.CANOverloadFrame.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.can.CANStandardFrame">
<em class="property">class </em><code class="descclassname">ripyl.protocol.can.</code><code class="descname">CANStandardFrame</code><span class="sig-paren">(</span><em>id</em>, <em>data</em>, <em>dlc=None</em>, <em>crc=None</em>, <em>ack=True</em>, <em>trim_bits=0</em>, <em>ifs_bits=3</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.can.CANStandardFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.protocol.can.CANFrame" title="ripyl.protocol.can.CANFrame"><code class="xref py py-class docutils literal"><span class="pre">ripyl.protocol.can.CANFrame</span></code></a></p>
<p>CAN frame format for 11-bit ID</p>
<dl class="method">
<dt id="ripyl.protocol.can.CANStandardFrame.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>id</em>, <em>data</em>, <em>dlc=None</em>, <em>crc=None</em>, <em>ack=True</em>, <em>trim_bits=0</em>, <em>ifs_bits=3</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.can.CANStandardFrame.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>id</strong> (<em>int</em>) – 11-bit CAN frame ID</li>
<li><strong>data</strong> (<em>sequence of int</em><em> or </em><em>None</em>) – Data bytes for a data frame. None or empty list for a remote frame.</li>
<li><strong>dlc</strong> (<em>int</em><em> or </em><em>None</em>) – The Data Length Code (number of data bytes) for the frame.</li>
<li><strong>crc</strong> (<em>int</em><em> or </em><em>None</em>) – The decoded CRC for the frame. Leave as None to generate CRC automatically.</li>
<li><strong>ack</strong> (<em>bool</em>) – Indicates that the ack field is dominant (True) or recessive (False).</li>
<li><strong>trim_bits</strong> (<em>int</em>) – The number of bits to trim off the end of the frame. Used to simulate error conditions.</li>
<li><strong>ifs_bits</strong> (<em>int</em>) – The number of Inter-Frame Space bits at the start of this frame. Normally 3.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.can.CANStandardFrame.get_bits">
<code class="descname">get_bits</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.can.CANStandardFrame.get_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate standard frame bits</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.can.CANStreamFrame">
<em class="property">class </em><code class="descclassname">ripyl.protocol.can.</code><code class="descname">CANStreamFrame</code><span class="sig-paren">(</span><em>bounds</em>, <em>frame</em>, <em>field_info=None</em>, <em>stuffed_bits=None</em>, <em>status=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.can.CANStreamFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><code class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></code></a></p>
<p>Encapsulates a CANFrame object into a StreamSegment</p>
<dl class="method">
<dt id="ripyl.protocol.can.CANStreamFrame.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>bounds</em>, <em>frame</em>, <em>field_info=None</em>, <em>stuffed_bits=None</em>, <em>status=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.can.CANStreamFrame.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.can.CANStreamStatus">
<em class="property">class </em><code class="descclassname">ripyl.protocol.can.</code><code class="descname">CANStreamStatus</code><a class="headerlink" href="#ripyl.protocol.can.CANStreamStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><code class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></code></a></p>
<p>Enumeration for CANStreamFrame status codes</p>
<dl class="attribute">
<dt id="ripyl.protocol.can.CANStreamStatus.AckError">
<code class="descname">AckError</code><em class="property"> = 204</em><a class="headerlink" href="#ripyl.protocol.can.CANStreamStatus.AckError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.can.CANStreamStatus.CRCError">
<code class="descname">CRCError</code><em class="property"> = 203</em><a class="headerlink" href="#ripyl.protocol.can.CANStreamStatus.CRCError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.can.CANStreamStatus.FormError">
<code class="descname">FormError</code><em class="property"> = 202</em><a class="headerlink" href="#ripyl.protocol.can.CANStreamStatus.FormError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.can.CANStreamStatus.ShortFrameError">
<code class="descname">ShortFrameError</code><em class="property"> = 201</em><a class="headerlink" href="#ripyl.protocol.can.CANStreamStatus.ShortFrameError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.can.CANTiming">
<em class="property">class </em><code class="descclassname">ripyl.protocol.can.</code><code class="descname">CANTiming</code><span class="sig-paren">(</span><em>prop</em>, <em>p1</em>, <em>ipt=2</em>, <em>resync_jump_quanta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.can.CANTiming" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Represent CAN bit timing and adaptive sampling point info</p>
<dl class="method">
<dt id="ripyl.protocol.can.CANTiming.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>prop</em>, <em>p1</em>, <em>ipt=2</em>, <em>resync_jump_quanta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.can.CANTiming.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>prop</strong> (<em>int</em>) – Propagataion time in quanta.</li>
<li><strong>p1</strong> (<em>int</em>) – Phase segment 1 time in quanta.</li>
<li><strong>ipt</strong> (<em>int</em>) – Information Processing Time in quanta.</li>
<li><strong>resync_jump_quanta</strong> (<em>int</em><em> or </em><em>None</em>) – The number of quanta to jump by on a resync. Default is minimum of 4 and p1.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.can.CANTiming.bit_period">
<code class="descname">bit_period</code><a class="headerlink" href="#ripyl.protocol.can.CANTiming.bit_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Total time covered by this timing specification</p>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.can.CANTiming.post_sample_delay">
<code class="descname">post_sample_delay</code><a class="headerlink" href="#ripyl.protocol.can.CANTiming.post_sample_delay" title="Permalink to this definition">¶</a></dt>
<dd><p>The delay from the sample point to the end of the bit</p>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.can.CANTiming.resync_jump">
<code class="descname">resync_jump</code><a class="headerlink" href="#ripyl.protocol.can.CANTiming.resync_jump" title="Permalink to this definition">¶</a></dt>
<dd><p>Time span for resync jump</p>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.can.CANTiming.resync_jump_quanta">
<code class="descname">resync_jump_quanta</code><a class="headerlink" href="#ripyl.protocol.can.CANTiming.resync_jump_quanta" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of quanta to jump for resync</p>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.can.CANTiming.sample_point_delay">
<code class="descname">sample_point_delay</code><a class="headerlink" href="#ripyl.protocol.can.CANTiming.sample_point_delay" title="Permalink to this definition">¶</a></dt>
<dd><p>The delay from the start of the bit to the sample point</p>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.can.CANTiming.set_quantum_period">
<code class="descname">set_quantum_period</code><span class="sig-paren">(</span><em>nominal_bit_period</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.can.CANTiming.set_quantum_period" title="Permalink to this definition">¶</a></dt>
<dd><p>Establish the time period for one quantum</p>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.can.CANTiming.total_quanta">
<code class="descname">total_quanta</code><a class="headerlink" href="#ripyl.protocol.can.CANTiming.total_quanta" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of quanta in this timing specification</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.can.can_crc15">
<code class="descclassname">ripyl.protocol.can.</code><code class="descname">can_crc15</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.can.can_crc15" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate CAN CRC-15 on data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>d</strong> (<em>sequence of int</em>) – Array of integers representing 0 or 1 bits in transmission order</td>
</tr>
</tbody>
</table>
<p>:param  :
:returns: Array of integers for each bit in the crc with msb first</p>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.can.can_decode">
<code class="descclassname">ripyl.protocol.can.</code><code class="descname">can_decode</code><span class="sig-paren">(</span><em>can</em>, <em>polarity=1</em>, <em>bit_rate=None</em>, <em>bit_timing=None</em>, <em>coerce_rates=None</em>, <em>logic_levels=None</em>, <em>stream_type=1</em>, <em>decode_info=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.can.can_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode a CAN data stream</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations.</p>
<p>Sample streams are a sequence of SampleChunk Objects. Edge streams are a sequence
of 2-tuples of (time, int) pairs. The type of stream is identified by the stream_type
parameter. Sample streams will be analyzed to find edge transitions representing
0 and 1 logic states of the waveforms. With sample streams, an initial block of data
is consumed to determine the most likely logic levels in the signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>can</strong> (<em>iterable of SampleChunk objects</em><em> or </em><em>(</em><em>float</em><em>, </em><em>int</em><em>) </em><em>pairs</em>) – A sample stream or edge stream representing a CAN data signal.
This can be one of CAN-High, CAN-Low, or the differential voltage between
them.</li>
<li><strong>polarity</strong> (<a class="reference internal" href="#ripyl.protocol.can.CANConfig" title="ripyl.protocol.can.CANConfig"><em>CANConfig</em></a>) – Set the polarity (idle state high or low). This will be low when the can
parameter is from CAN-Low, high when CAN-High, and dependent on probe orientation
when using a differential input.</li>
<li><strong>bit_rate</strong> (<em>number</em><em> or </em><em>None</em>) – The bit rate of the stream. If None, the first 50 edges will be analyzed to
automatically determine the most likely bit rate for the stream. On average
50 edges will occur after 11 bytes have been captured.</li>
<li><strong>bit_timing</strong> (<a class="reference internal" href="#ripyl.protocol.can.CANTiming" title="ripyl.protocol.can.CANTiming"><em>CANTiming</em></a><em> or </em><em>None</em>) – An optional CANTiming object that specifies the time quanta for each bit phase.
If None, a default timing object is used with prop. delay = 1q and p1 &amp; p2 = 4q.</li>
<li><strong>coerce_rates</strong> (<em>sequence of number</em><em> or </em><em>None</em>) – An optional list of standard bit rates to coerce the automatically detected
bit rate to.</li>
<li><strong>logic_levels</strong> (<em>(</em><em>float</em><em>, </em><em>float</em><em>) or </em><em>None</em>) – Optional pair that indicates (low, high) logic levels of the sample
stream. When present, auto level detection is disabled. This has no effect on
edge streams.</li>
<li><strong>stream_type</strong> (<a class="reference internal" href="ripyl.html#ripyl.streaming.StreamType" title="ripyl.streaming.StreamType"><em>streaming.StreamType</em></a>) – A StreamType value indicating that the can parameter represents either Samples
or Edges</li>
<li><strong>decode_info</strong> (<em>dict</em><em> or </em><em>None</em>) – An optional dictionary object that is used to monitor the results of
automatic parameter analysis and retrieve bit timing.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param  :
:returns: An iterator yielding  a series of CANStreamFrame objects. Each frame contains subrecords marking the location</p>
<blockquote>
<div>of sub-elements within the frame. CRC and Ack errors are recorded as an error status in their
respective subrecords.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">AutoLevelError if stream_type = Samples and the logic levels cannot
be determined.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">AutoRateError if auto-rate detection is active and the bit rate cannot
be determined.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.can.can_id">
<code class="descclassname">ripyl.protocol.can.</code><code class="descname">can_id</code><span class="sig-paren">(</span><em>variant</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.can.can_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a CAN ID for a protocol variant from separate fields</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>variant</strong> (<em>string</em>) – Name of the variant to take field definitions from.</li>
<li><strong>kwargs</strong> (<em>dict of string:int</em>) – Each additional keyword argument names a field for the selected variant.
The value is applied to the range of bits specified for the field.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An int representing an 11-bit or 29-bit can id composed from the values in kwargs.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.can.can_synth">
<code class="descclassname">ripyl.protocol.can.</code><code class="descname">can_synth</code><span class="sig-paren">(</span><em>frames</em>, <em>bit_rate</em>, <em>idle_start=0.0</em>, <em>idle_end=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.can.can_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate synthesized CAN data streams</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>frames</strong> (<em>sequence of CANFrame compatible objects</em>) – Frames to be synthesized.</li>
<li><strong>bit_rate</strong> (<em>number</em>) – The frequency of the clock generator</li>
<li><strong>idle_start</strong> (<em>float</em>) – The amount of idle time before the transmission of frames begins.</li>
<li><strong>idle_end</strong> (<em>float</em>) – The amount of idle time after the last frame.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  an edge stream of (float, int) pairs. The first element in the iterator
is the initial state of the stream.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.protocol.ethernet">
<span id="ripyl-protocol-ethernet-module"></span><h2>ripyl.protocol.ethernet module<a class="headerlink" href="#module-ripyl.protocol.ethernet" title="Permalink to this headline">¶</a></h2>
<p>Ethernet protocol decoder</p>
<dl class="class">
<dt id="ripyl.protocol.ethernet.EthernetFrame">
<em class="property">class </em><code class="descclassname">ripyl.protocol.ethernet.</code><code class="descname">EthernetFrame</code><span class="sig-paren">(</span><em>dest</em>, <em>source</em>, <em>data</em>, <em>length_type=None</em>, <em>tags=None</em>, <em>crc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ethernet.EthernetFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Ethernet frame object</p>
<dl class="method">
<dt id="ripyl.protocol.ethernet.EthernetFrame.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>dest</em>, <em>source</em>, <em>data</em>, <em>length_type=None</em>, <em>tags=None</em>, <em>crc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ethernet.EthernetFrame.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dest</strong> (<a class="reference internal" href="#ripyl.protocol.ethernet.MACAddr" title="ripyl.protocol.ethernet.MACAddr"><em>MACAddr</em></a><em>, </em><em>str</em><em>, or </em><em>sequence of int</em>) – The destination address of the frame.</li>
<li><strong>source</strong> (<a class="reference internal" href="#ripyl.protocol.ethernet.MACAddr" title="ripyl.protocol.ethernet.MACAddr"><em>MACAddr</em></a><em>, </em><em>str</em><em>, or </em><em>sequence of int</em>) – The source address of the frame.</li>
<li><strong>data</strong> (<em>sequence of int</em>) – The data for the frame. Padding is not necessary.</li>
<li><strong>length_type</strong> (<em>int</em><em> or </em><em>None</em>) – The Ethertype / length field. Ethertypes should be &gt;= 0x600.</li>
<li><strong>tags</strong> (<em>sequence of EthernetTag</em><em> or </em><em>None</em>) – Optional sequence of 802.1Q tags to insert into frame.</li>
<li><strong>crc</strong> (<em>int</em><em> or </em><em>None</em>) – The decoded CRC for the frame. Leave as None to generate CRC automatically.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.ethernet.EthernetFrame.bit_stream">
<code class="descname">bit_stream</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ethernet.EthernetFrame.bit_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the sequence of raw bits for the frame.</p>
<p>This includes the SOF and SFD at the start and the IDL phase at end of frame.</p>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.ethernet.EthernetFrame.bytes">
<code class="descname">bytes</code><a class="headerlink" href="#ripyl.protocol.ethernet.EthernetFrame.bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the bytes for this frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A series of bytes representing the header, payload, and crc. this does not</td>
</tr>
</tbody>
</table>
<p>include the SOF and SFD sequence.</p>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.ethernet.EthernetFrame.crc">
<code class="descname">crc</code><a class="headerlink" href="#ripyl.protocol.ethernet.EthernetFrame.crc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ripyl.protocol.ethernet.EthernetFrame.crc_is_valid">
<code class="descname">crc_is_valid</code><span class="sig-paren">(</span><em>recv_crc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ethernet.EthernetFrame.crc_is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a decoded CRC is valid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>recv_crc</strong> (<em>int</em><em> or </em><em>None</em>) – The decoded CRC to check against. If None, the CRC passed in the constructor is used.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True when the crc is correct.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.ethernet.EthernetFrame.length_type">
<code class="descname">length_type</code><a class="headerlink" href="#ripyl.protocol.ethernet.EthernetFrame.length_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.ethernet.EthernetLinkCode">
<em class="property">class </em><code class="descclassname">ripyl.protocol.ethernet.</code><code class="descname">EthernetLinkCode</code><span class="sig-paren">(</span><em>selector</em>, <em>tech_ability</em>, <em>rem_fault</em>, <em>ack</em>, <em>next_page</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ethernet.EthernetLinkCode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Representation of the pulses in a 100Mbps Ethernet autonegotiation</p>
<dl class="method">
<dt id="ripyl.protocol.ethernet.EthernetLinkCode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>selector</em>, <em>tech_ability</em>, <em>rem_fault</em>, <em>ack</em>, <em>next_page</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ethernet.EthernetLinkCode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>selector</strong> (<em>int</em>) – Identify which standard is in use</li>
<li><strong>tech_ability</strong> (<em>int</em>) – Technology ability. Identifies posible modes of operation.</li>
<li><strong>rem_fault</strong> (<em>int</em><em> or </em><em>bool</em>) – Flag indicating a link failure</li>
<li><strong>ack</strong> (<em>int</em><em> or </em><em>bool</em>) – Flag to indicate reception of the base link code word.</li>
<li><strong>next_page</strong> (<em>int</em><em> or </em><em>bool</em>) – Flag to indicate intention to send other link code words.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.ethernet.EthernetLinkCode.word">
<code class="descname">word</code><a class="headerlink" href="#ripyl.protocol.ethernet.EthernetLinkCode.word" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate 16-bit word from the fields</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.ethernet.EthernetLinkTest">
<em class="property">class </em><code class="descclassname">ripyl.protocol.ethernet.</code><code class="descname">EthernetLinkTest</code><span class="sig-paren">(</span><em>link_code=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ethernet.EthernetLinkTest" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>An link test pulse or auto-negotiation pulse stream</p>
<dl class="method">
<dt id="ripyl.protocol.ethernet.EthernetLinkTest.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>link_code=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ethernet.EthernetLinkTest.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>link_code</strong> (<em>int</em><em> or </em><em>None</em>) – When None, this object represents a single link test pulse.
When an int, this object represents a series of pulses for the link code</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.ethernet.EthernetLinkTest.edges">
<code class="descname">edges</code><span class="sig-paren">(</span><em>bit_period</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ethernet.EthernetLinkTest.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the edges for this object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>bit_period</strong> (<em>float</em>) – The period of a single bit.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of (float, int) edges representing the pulse(s) for this object</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.ethernet.EthernetStreamFrame">
<em class="property">class </em><code class="descclassname">ripyl.protocol.ethernet.</code><code class="descname">EthernetStreamFrame</code><span class="sig-paren">(</span><em>bounds</em>, <em>frame</em>, <em>status=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ethernet.EthernetStreamFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><code class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></code></a></p>
<p>Encapsulates an EthernetFrame object into a StreamSegment</p>
<dl class="method">
<dt id="ripyl.protocol.ethernet.EthernetStreamFrame.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>bounds</em>, <em>frame</em>, <em>status=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ethernet.EthernetStreamFrame.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.ethernet.EthernetStreamStatus">
<em class="property">class </em><code class="descclassname">ripyl.protocol.ethernet.</code><code class="descname">EthernetStreamStatus</code><a class="headerlink" href="#ripyl.protocol.ethernet.EthernetStreamStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><code class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></code></a></p>
<p>Enumeration for EthernetStreamFrame status codes</p>
<dl class="attribute">
<dt id="ripyl.protocol.ethernet.EthernetStreamStatus.CRCError">
<code class="descname">CRCError</code><em class="property"> = 201</em><a class="headerlink" href="#ripyl.protocol.ethernet.EthernetStreamStatus.CRCError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.ethernet.EthernetTag">
<em class="property">class </em><code class="descclassname">ripyl.protocol.ethernet.</code><code class="descname">EthernetTag</code><span class="sig-paren">(</span><em>tpid</em>, <em>tci</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ethernet.EthernetTag" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Tag object representing 802.1Q tag</p>
<dl class="method">
<dt id="ripyl.protocol.ethernet.EthernetTag.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>tpid</em>, <em>tci</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ethernet.EthernetTag.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.ethernet.EthernetTag.bytes">
<code class="descname">bytes</code><a class="headerlink" href="#ripyl.protocol.ethernet.EthernetTag.bytes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.ethernet.EthernetTag.dei">
<code class="descname">dei</code><a class="headerlink" href="#ripyl.protocol.ethernet.EthernetTag.dei" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.ethernet.EthernetTag.pcp">
<code class="descname">pcp</code><a class="headerlink" href="#ripyl.protocol.ethernet.EthernetTag.pcp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.ethernet.EthernetTag.vid">
<code class="descname">vid</code><a class="headerlink" href="#ripyl.protocol.ethernet.EthernetTag.vid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.ethernet.MACAddr">
<em class="property">class </em><code class="descclassname">ripyl.protocol.ethernet.</code><code class="descname">MACAddr</code><span class="sig-paren">(</span><em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ethernet.MACAddr" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Ethernet MAC address</p>
<dl class="method">
<dt id="ripyl.protocol.ethernet.MACAddr.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>addr</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ethernet.MACAddr.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>addr</strong> (<em>str</em><em> or </em><em>sequence of int</em>) – The address can be specified as in two formats: a list of int or a string. The string
is a series of hex digits with optional colon separators on byteboundaries.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">ValueError if the address does not contain 6 bytes.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.ethernet.add_overshoot">
<code class="descclassname">ripyl.protocol.ethernet.</code><code class="descname">add_overshoot</code><span class="sig-paren">(</span><em>bits</em>, <em>duration</em>, <em>overshoot=0.75</em>, <em>undershoot=0.8</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ethernet.add_overshoot" title="Permalink to this definition">¶</a></dt>
<dd><p>Add simulated overshoot to an edge stream</p>
<p>This function is intended to simulate the overshoot behavior produced by the
output drivers and magnetics of 10Base-T ethernet. This is done crudely by scaling
the edge stream values by the overshoot and undershoot factors. This results in a
non-standard edge stream that can be processed by synth_wave() to create a
realistic sampled waveform but is otherwise not useful.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>bits</strong> (<em>iterable of</em><em> (</em><em>float</em><em>, </em><em>int</em><em>)</em>) – A differential edge stream to add overshoot to.</li>
<li><strong>duration</strong> (<em>float</em>) – The amount of time to add overshoot after each edge transition.</li>
<li><strong>overshoot</strong> (<em>float</em>) – The fraction of a high-level that the overshoot extends past.</li>
<li><strong>undershoot</strong> (<em>float</em>) – The fraction of the overshoot that the undershoot extends past. Only used for
transitions to idle.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  an edge stream with overshoot transitions inserted.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.ethernet.ethernet_decode">
<code class="descclassname">ripyl.protocol.ethernet.</code><code class="descname">ethernet_decode</code><span class="sig-paren">(</span><em>rxtx</em>, <em>tag_ethertypes=None</em>, <em>logic_levels=None</em>, <em>stream_type=1</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ethernet.ethernet_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode an ethernet data stream</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations.</p>
<p>Sample streams are a sequence of SampleChunk Objects. Edge streams are a sequence
of 2-tuples of (time, int) pairs. The type of stream is identified by the stream_type
parameter. Sample streams will be analyzed to find edge transitions representing
0 and 1 logic states of the waveforms. With sample streams, an initial block of data
is consumed to determine the most likely logic levels in the signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>rxtx</strong> (<em>iterable of SampleChunk objects</em><em> or </em><em>(</em><em>float</em><em>, </em><em>int</em><em>) </em><em>pairs</em>) – A sample stream or edge stream representing a differential ethernet signal.</li>
<li><strong>tag_ethertypes</strong> (<em>sequence of int</em><em> or </em><em>None</em>) – The ethertypes to use for identifying 802.1Q tags. Default is 0x8100, 0x88a8, and 0x9100.</li>
<li><strong>logic_levels</strong> (<em>(</em><em>float</em><em>, </em><em>float</em><em>) or </em><em>None</em>) – Optional pair that indicates (low, high) logic levels of the sample
stream. When present, auto level detection is disabled. This has no effect on
edge streams.</li>
<li><strong>stream_type</strong> (<a class="reference internal" href="ripyl.html#ripyl.streaming.StreamType" title="ripyl.streaming.StreamType"><em>streaming.StreamType</em></a>) – A StreamType value indicating that the can parameter represents either Samples
or Edges</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An iterator yielding  a series of EthernetStreamFrame objects. Each frame contains subrecords marking the location
of sub-elements within the frame. CRC errors are recorded as an error status in their
respective subrecords.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">AutoLevelError if stream_type = Samples and the logic levels cannot
be determined.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">StreamError if ethernet speed cannot be determined.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.ethernet.ethernet_synth">
<code class="descclassname">ripyl.protocol.ethernet.</code><code class="descname">ethernet_synth</code><span class="sig-paren">(</span><em>frames</em>, <em>overshoot=None</em>, <em>idle_start=0.0</em>, <em>frame_interval=0.0</em>, <em>idle_end=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ethernet.ethernet_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate synthesized Ethernet frames</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>frames</strong> (<em>sequence of EthernetFrame</em>) – Frames to be synthesized.</li>
<li><strong>overshoot</strong> (<em>None</em><em> or </em><em>(</em><em>float</em><em>, </em><em>float</em><em>)</em>) – When a pair of floats is provided these indicate the overshoot parameters to add
to the waveform. The first number is the fraction of a bit period that the overshoot
covers. This should be less than 0.5. The second number is the fraction of a high-level
that the overshoot extends past. When used, the edge stream must be converted to a
sample stream with low-pass filtering by synth_wave() before it accurately represents
overshoot.</li>
<li><strong>idle_start</strong> (<em>float</em>) – The amount of idle time before the transmission of frames begins.</li>
<li><strong>frame_interval</strong> (<em>float</em>) – The amount of time between frames.</li>
<li><strong>idle_end</strong> (<em>float</em>) – The amount of idle time after the last frame.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  an edge stream of (float, int) pairs. The first element in the iterator
is the initial state of the stream.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.ethernet.table_ethernet_crc32">
<code class="descclassname">ripyl.protocol.ethernet.</code><code class="descname">table_ethernet_crc32</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ethernet.table_ethernet_crc32" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Ethernet CRC-32 on data</p>
<p>This is a table-based byte-wise implementation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>d</strong> (<em>sequence of int</em>) – Array of integers representing bytes</td>
</tr>
</tbody>
</table>
<p>:param  :
:returns: An integer with the crc value.</p>
</dd></dl>

</div>
<div class="section" id="module-ripyl.protocol.i2c">
<span id="ripyl-protocol-i2c-module"></span><h2>ripyl.protocol.i2c module<a class="headerlink" href="#module-ripyl.protocol.i2c" title="Permalink to this headline">¶</a></h2>
<p>I2C protocol decoder</p>
<dl class="class">
<dt id="ripyl.protocol.i2c.I2C">
<em class="property">class </em><code class="descclassname">ripyl.protocol.i2c.</code><code class="descname">I2C</code><a class="headerlink" href="#ripyl.protocol.i2c.I2C" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><code class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></code></a></p>
<p>Enumeration for I2C r/w bit states</p>
<dl class="attribute">
<dt id="ripyl.protocol.i2c.I2C.Read">
<code class="descname">Read</code><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.i2c.I2C.Read" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.i2c.I2C.Write">
<code class="descname">Write</code><em class="property"> = 0</em><a class="headerlink" href="#ripyl.protocol.i2c.I2C.Write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.i2c.I2CAddress">
<em class="property">class </em><code class="descclassname">ripyl.protocol.i2c.</code><code class="descname">I2CAddress</code><span class="sig-paren">(</span><em>bounds</em>, <em>address=None</em>, <em>r_wn=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.i2c.I2CAddress" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><code class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></code></a></p>
<p>Segment for an I2C address</p>
<p>The byte(s) composing the address are contained as subrecords</p>
<dl class="method">
<dt id="ripyl.protocol.i2c.I2CAddress.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>bounds</em>, <em>address=None</em>, <em>r_wn=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.i2c.I2CAddress.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>r_wn</strong> (<em>int</em>) – Read (1) / Write (0) bit</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.i2c.I2CAddress.address">
<code class="descname">address</code><a class="headerlink" href="#ripyl.protocol.i2c.I2CAddress.address" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias of data attribute</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.i2c.I2CByte">
<em class="property">class </em><code class="descclassname">ripyl.protocol.i2c.</code><code class="descname">I2CByte</code><span class="sig-paren">(</span><em>bounds</em>, <em>data=None</em>, <em>ack_bit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.i2c.I2CByte" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><code class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></code></a></p>
<p>Segment for a byte of I2C data</p>
<dl class="method">
<dt id="ripyl.protocol.i2c.I2CByte.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>bounds</em>, <em>data=None</em>, <em>ack_bit=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.i2c.I2CByte.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.i2c.I2CTransfer">
<em class="property">class </em><code class="descclassname">ripyl.protocol.i2c.</code><code class="descname">I2CTransfer</code><span class="sig-paren">(</span><em>r_wn</em>, <em>address</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.i2c.I2CTransfer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamRecord" title="ripyl.streaming.StreamRecord"><code class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamRecord</span></code></a></p>
<p>Represent a transaction over the I2C bus</p>
<dl class="method">
<dt id="ripyl.protocol.i2c.I2CTransfer.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>r_wn</em>, <em>address</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.i2c.I2CTransfer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>r_wn</strong> (<em>int</em>) – Read/write mode for the transfer</li>
<li><strong>address</strong> (<em>int</em>) – Address of the transfer. Can be either a 7-bit or 10-bit address.</li>
<li><strong>data</strong> (<em>sequence of ints</em>) – Array of bytes sent in the transfer</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.i2c.I2CTransfer.ack_bits">
<code class="descname">ack_bits</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.i2c.I2CTransfer.ack_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a list of ack bits for each byte of data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of ints</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.i2c.I2CTransfer.bytes">
<code class="descname">bytes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.i2c.I2CTransfer.bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list of raw bytes for the transfer including the formatted address</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of ints</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.i2c.I2CTransfer.end_time">
<code class="descname">end_time</code><a class="headerlink" href="#ripyl.protocol.i2c.I2CTransfer.end_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.i2c.I2CTransfer.start_time">
<code class="descname">start_time</code><a class="headerlink" href="#ripyl.protocol.i2c.I2CTransfer.start_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.i2c.i2c_decode">
<code class="descclassname">ripyl.protocol.i2c.</code><code class="descname">i2c_decode</code><span class="sig-paren">(</span><em>scl</em>, <em>sda</em>, <em>logic_levels=None</em>, <em>stream_type=1</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.i2c.i2c_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode an I2C data stream</p>
<p>This is a generator function that can be used in a pipeline of waveform
processing operations.</p>
<p>The scl, and sda parameters are edge or sample streams.
Sample streams are a sequence of SampleChunk Objects. Edge streams are a sequence
of 2-tuples of (time, int) pairs. The type of stream is identified by the stream_type
parameter. Sample streams will be analyzed to find edge transitions representing
0 and 1 logic states of the waveforms. With sample streams, an initial block of data
on the scl stream is consumed to determine the most likely logic levels in the signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>scl</strong> (<em>iterable of SampleChunk objects</em><em> or </em><em>(</em><em>float</em><em>, </em><em>int</em><em>) </em><em>pairs</em>) – A sample stream or edge stream representing the I2C serial clock</li>
<li><strong>sda</strong> (<em>iterable of SampleChunk objects</em><em> or </em><em>(</em><em>float</em><em>, </em><em>int</em><em>) </em><em>pairs</em>) – A sample stream or edge stream representing the I2C serial data</li>
<li><strong>logic_levels</strong> (<em>(</em><em>float</em><em>, </em><em>float</em><em>) or </em><em>None</em>) – Optional pair that indicates (low, high) logic levels of the sample
stream. When present, auto level detection is disabled. This has no effect on
edge streams.</li>
<li><strong>stream_type</strong> (<a class="reference internal" href="ripyl.html#ripyl.streaming.StreamType" title="ripyl.streaming.StreamType"><em>streaming.StreamType</em></a>) – Indicates the type of stream used for scl and sda.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>:param  :</dt>
<dd>When StreamType.Samples, the iterators represent a sequence of samples.
Each sample is a 2-tuple representing the time of the sample and the sample’s
value. When this type is used, the scl stream is analyzed to determine the
logic levels of the two streams.</dd>
<dt>:param  :</dt>
<dd>When StreamType.Edges, the iterators represent a series of edges.
scl and sda are iterables of 2-tuples representing each edge transition.
The 2-tuples <em>must</em> be in the absolute time form (time, logic level).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">An iterator yielding  a series of StreamRecord-based objects. These will be one of three event types
or two data types. The three events are represented by StreamEvent object with these
obj.kind attribute values:<blockquote>
<div><ul class="simple">
<li>’I2C start’   The start of an I2C transfer</li>
<li>’I2C restart’ A start condition during a transfer</li>
<li>’I2C stop’    The end of a transfer</li>
</ul>
</div></blockquote>
<p>The two data types are represented by the objects I2CAddress and I2CByte. The former
is a 7-bit or 10-bit address from the start of a transfer or restart. The latter contains
the data read or written during the transfer. I2CByte has an attribute ack_bit that
records the value of the ACK for that byte. I2CAddress has a r_wn attribute that indicates
if the transfer is a read or write. The subrecords attribute contains the I2CByte object
or objects that composed the address.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">AutoLevelError when the stream_type is Samples and the logic levels cannot
be determined automatically.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.i2c.i2c_synth">
<code class="descclassname">ripyl.protocol.i2c.</code><code class="descname">i2c_synth</code><span class="sig-paren">(</span><em>transfers</em>, <em>clock_freq</em>, <em>idle_start=0.0</em>, <em>transfer_interval=0.0</em>, <em>idle_end=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.i2c.i2c_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate synthesized I2C waveforms</p>
<p>This function simulates I2C transfers on the SCL and SDA signals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>transfers</strong> (<em>sequence of I2CTransfer objects</em>) – Data to be synthesized.</li>
<li><strong>clock_freq</strong> (<em>float</em>) – Clock frequency for the I2C bus. Standard rates are 100kHz (100.0e3)
and 400kHz (400.0e3) but any frequency can be specified.</li>
<li><strong>idle_start</strong> (<em>float</em>) – The amount of idle time before the transmission of transfers begins</li>
<li><strong>transfer_interval</strong> (<em>float</em>) – The amount of time between transfers</li>
<li><strong>idle_end</strong> (<em>float</em>) – The amount of idle time after the last transfer</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A pair of iterators representing the two edge streams for scl, and sda
respectively. Each edge stream pair is in (time, value) format representing the
time and logic value (0 or 1) for each edge transition. The first elements in the
iterators are the initial state of the waveforms.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.i2c.reconstruct_i2c_transfers">
<code class="descclassname">ripyl.protocol.i2c.</code><code class="descname">reconstruct_i2c_transfers</code><span class="sig-paren">(</span><em>records</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.i2c.reconstruct_i2c_transfers" title="Permalink to this definition">¶</a></dt>
<dd><p>Recreate I2CTransfer objects using the output of i2c_decode()</p>
<p>This is a generator function that can be used in a pipeline of waveform
processing operations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>records</strong> (<em>sequence of I2CByte and I2CAddress</em>) – An iterable of records produced by i2c_decode().
All StreamEvent records are discarded.</td>
</tr>
</tbody>
</table>
<p>:param  :
:returns: An iterator yielding  a stream of I2CTransfer objects containing aggregated address and data</p>
<blockquote>
<div>from the input records.</div></blockquote>
</dd></dl>

</div>
<div class="section" id="module-ripyl.protocol.i2s">
<span id="ripyl-protocol-i2s-module"></span><h2>ripyl.protocol.i2s module<a class="headerlink" href="#module-ripyl.protocol.i2s" title="Permalink to this headline">¶</a></h2>
<p>I2S protocol decoder</p>
<dl class="class">
<dt id="ripyl.protocol.i2s.I2SFrame">
<em class="property">class </em><code class="descclassname">ripyl.protocol.i2s.</code><code class="descname">I2SFrame</code><span class="sig-paren">(</span><em>bounds</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.i2s.I2SFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><code class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></code></a></p>
<p>Frame object for I2S data</p>
<dl class="method">
<dt id="ripyl.protocol.i2s.I2SFrame.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>bounds</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.i2s.I2SFrame.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>bounds</strong> (<em>(</em><em>float</em><em>, </em><em>float</em><em>)</em>) – 2-tuple (start_time, end_time) for the bounds of the frame</li>
<li><strong>data</strong> (<em>sequence of int</em>) – Data representing the sample(s) in the frame</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.i2s.I2SVariant">
<em class="property">class </em><code class="descclassname">ripyl.protocol.i2s.</code><code class="descname">I2SVariant</code><a class="headerlink" href="#ripyl.protocol.i2s.I2SVariant" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><code class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></code></a></p>
<dl class="attribute">
<dt id="ripyl.protocol.i2s.I2SVariant.DSPModeLongSync">
<code class="descname">DSPModeLongSync</code><em class="property"> = 2</em><a class="headerlink" href="#ripyl.protocol.i2s.I2SVariant.DSPModeLongSync" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.i2s.I2SVariant.DSPModeShortSync">
<code class="descname">DSPModeShortSync</code><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.i2s.I2SVariant.DSPModeShortSync" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.i2s.I2SVariant.Standard">
<code class="descname">Standard</code><em class="property"> = 0</em><a class="headerlink" href="#ripyl.protocol.i2s.I2SVariant.Standard" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.i2s.duplicate">
<code class="descclassname">ripyl.protocol.i2s.</code><code class="descname">duplicate</code><span class="sig-paren">(</span><em>samples</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.i2s.duplicate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ripyl.protocol.i2s.i2s_decode">
<code class="descclassname">ripyl.protocol.i2s.</code><code class="descname">i2s_decode</code><span class="sig-paren">(</span><em>sck</em>, <em>sd</em>, <em>ws</em>, <em>word_size</em>, <em>frame_size=None</em>, <em>cpol=0</em>, <em>wspol=0</em>, <em>msb_justified=True</em>, <em>channels=2</em>, <em>i2s_variant=0</em>, <em>data_offset=1</em>, <em>logic_levels=None</em>, <em>stream_type=1</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.i2s.i2s_decode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ripyl.protocol.i2s.i2s_synth">
<code class="descclassname">ripyl.protocol.i2s.</code><code class="descname">i2s_synth</code><span class="sig-paren">(</span><em>data</em>, <em>word_size</em>, <em>frame_size</em>, <em>sample_rate</em>, <em>cpol=0</em>, <em>wspol=0</em>, <em>msb_justified=True</em>, <em>channels=2</em>, <em>i2s_variant=0</em>, <em>data_offset=1</em>, <em>idle_start=0.0</em>, <em>idle_end=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.i2s.i2s_synth" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ripyl.protocol.i2s.mono_to_stereo">
<code class="descclassname">ripyl.protocol.i2s.</code><code class="descname">mono_to_stereo</code><span class="sig-paren">(</span><em>samples</em>, <em>duplicate_samples=True</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.i2s.mono_to_stereo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ripyl.protocol.i2s.spi_decode">
<code class="descclassname">ripyl.protocol.i2s.</code><code class="descname">spi_decode</code><span class="sig-paren">(</span><em>clk</em>, <em>data_io</em>, <em>cs=None</em>, <em>cpol=0</em>, <em>cpha=0</em>, <em>lsb_first=True</em>, <em>logic_levels=None</em>, <em>stream_type=1</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.i2s.spi_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode an SPI data stream</p>
<p>This is a generator function that can be used in a pipeline of waveform
processing operations.</p>
<p>The clk, data_io, and cs parameters are edge or sample streams.
Sample streams are a sequence of SampleChunk Objects. Edge streams are a sequence
of 2-tuples of (time, int) pairs. The type of stream is identified by the stream_type
parameter. Sample streams will be analyzed to find edge transitions representing
0 and 1 logic states of the waveforms. With sample streams, an initial block of data
on the clk stream is consumed to determine the most likely logic levels in the signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clk</strong> (<em>iterable of SampleChunk objects</em><em> or </em><em>(</em><em>float</em><em>, </em><em>int</em><em>) </em><em>pairs</em>) – A sample stream or edge stream representing an SPI clk signal</li>
<li><strong>data_io</strong> (<em>iterable of SampleChunk objects</em><em> or </em><em>(</em><em>float</em><em>, </em><em>int</em><em>) </em><em>pairs</em>) – A sample stream or edge stream representing an SPI MOSI or MISO signal.</li>
<li><strong>cs</strong> (<em>iterable of SampleChunk objects</em><em> or </em><em>(</em><em>float</em><em>, </em><em>int</em><em>) </em><em>pairs</em><em> or </em><em>None</em>) – A sample stream or edge stream representing an SPI chip select signal.
Can be None if cs is not available.</li>
<li><strong>cpol</strong> (<em>int</em>) – Clock polarity: 0 or 1 (the idle state of the clock signal)</li>
<li><strong>cpha</strong> (<em>int</em>) – Clock phase: 0 or 1 (data is sampled on the 1st clock edge (0) or the 2nd (1))</li>
<li><strong>lsb_first</strong> (<em>bool</em>) – Flag indicating whether the Least Significant Bit is transmitted first.</li>
<li><strong>logic_levels</strong> (<em>(</em><em>float</em><em>, </em><em>float</em><em>) or </em><em>None</em>) – Optional pair that indicates (low, high) logic levels of the sample
stream. When present, auto level detection is disabled. This has no effect on
edge streams.</li>
<li><strong>stream_type</strong> (<a class="reference internal" href="ripyl.html#ripyl.streaming.StreamType" title="ripyl.streaming.StreamType"><em>streaming.StreamType</em></a>) – A StreamType value indicating that the clk, data_io, and cs parameters represent either Samples
or Edges</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An iterator yielding  a series of SPIFrame objects.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">AutoLevelError if stream_type = Samples and the logic levels cannot
be determined.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.i2s.stereo_to_mono">
<code class="descclassname">ripyl.protocol.i2s.</code><code class="descname">stereo_to_mono</code><span class="sig-paren">(</span><em>samples</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.i2s.stereo_to_mono" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-ripyl.protocol.iso_k_line">
<span id="ripyl-protocol-iso-k-line-module"></span><h2>ripyl.protocol.iso_k_line module<a class="headerlink" href="#module-ripyl.protocol.iso_k_line" title="Permalink to this headline">¶</a></h2>
<p>ISO K-line protocol decoder</p>
<p>Decodes ISO9141 and ISO14230 automotive data bus protocols</p>
<dl class="class">
<dt id="ripyl.protocol.iso_k_line.ISO14230Header">
<em class="property">class </em><code class="descclassname">ripyl.protocol.iso_k_line.</code><code class="descname">ISO14230Header</code><span class="sig-paren">(</span><em>option</em>, <em>target</em>, <em>source</em>, <em>length=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.iso_k_line.ISO14230Header" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>ISO14230 header object</p>
<dl class="docutils">
<dt>Header byte 1: length 0x10nnnnnn</dt>
<dd>5-0 data bytes in message</dd>
</dl>
<p>Header byte 2: optional data byte count if nnnnnn is 0</p>
<p>Header byte 2(3): target address
Header byte 3(4): source address</p>
<dl class="method">
<dt id="ripyl.protocol.iso_k_line.ISO14230Header.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>option</em>, <em>target</em>, <em>source</em>, <em>length=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.iso_k_line.ISO14230Header.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>option, target, source, length</dt>
<dd>USBFrame objects for the header bytes</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.iso_k_line.ISO14230Header.bytes">
<code class="descname">bytes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.iso_k_line.ISO14230Header.bytes" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of header bytes in original order</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.iso_k_line.ISO9141Header">
<em class="property">class </em><code class="descclassname">ripyl.protocol.iso_k_line.</code><code class="descname">ISO9141Header</code><span class="sig-paren">(</span><em>option</em>, <em>target</em>, <em>source</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.iso_k_line.ISO9141Header" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>ISO9141 header object</p>
<p>Header byte 1: option</p>
<div class="line-block">
<div class="line">7-5 priority: 000 = high, 111 = low</div>
<div class="line">4   header type: 0 = 3-byte; 1 = 1-byte</div>
<div class="line">3   in frame response: 0 = required (Ford); 1 = not allowed (GM)</div>
<div class="line">2   addressing mode: 1 = physical; 0 = functional</div>
<div class="line">1-0 message type</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>|</strong> – </td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line">message type:</div>
<div class="line">bit: 3 2 1 0</div>
<div class="line-block">
<div class="line">——-</div>
<div class="line">1 0 0 0 function</div>
<div class="line">1 0 0 1 broadcast</div>
<div class="line">1 0 1 0 query</div>
<div class="line">1 0 1 1 read</div>
<div class="line">1 1 0 0 node-to-node</div>
<div class="line">1 1 0 1 reserved</div>
<div class="line">1 1 1 0 reserved</div>
<div class="line">1 1 1 1 reserved</div>
</div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>|</strong> – </td>
</tr>
</tbody>
</table>
<p>Header byte 2: target address
Header byte 3: source address</p>
<dl class="method">
<dt id="ripyl.protocol.iso_k_line.ISO9141Header.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>option</em>, <em>target</em>, <em>source</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.iso_k_line.ISO9141Header.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>option, target, source</dt>
<dd>USBFrame objects for the header bytes</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.iso_k_line.ISO9141Header.bytes">
<code class="descname">bytes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.iso_k_line.ISO9141Header.bytes" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of header bytes in original order</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.iso_k_line.ISO9141Init">
<em class="property">class </em><code class="descclassname">ripyl.protocol.iso_k_line.</code><code class="descname">ISO9141Init</code><span class="sig-paren">(</span><em>recs</em>, <em>status=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.iso_k_line.ISO9141Init" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><code class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></code></a></p>
<p>Encapsulates initialization exchange before messaging begins on ISO9141
These are the bytes in the 0x55, key1, key2, ~key2 ~wakeup init sequence.</p>
<dl class="method">
<dt id="ripyl.protocol.iso_k_line.ISO9141Init.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>recs</em>, <em>status=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.iso_k_line.ISO9141Init.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.iso_k_line.KLineMessage">
<em class="property">class </em><code class="descclassname">ripyl.protocol.iso_k_line.</code><code class="descname">KLineMessage</code><span class="sig-paren">(</span><em>msg_type</em>, <em>header</em>, <em>data</em>, <em>checksum</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineMessage" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.protocol.obd2.OBD2Message" title="ripyl.protocol.obd2.OBD2Message"><code class="xref py py-class docutils literal"><span class="pre">ripyl.protocol.obd2.OBD2Message</span></code></a></p>
<p>Message object for the K-line protocols ISO9141 and ISO14230</p>
<dl class="method">
<dt id="ripyl.protocol.iso_k_line.KLineMessage.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>msg_type</em>, <em>header</em>, <em>data</em>, <em>checksum</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineMessage.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ripyl.protocol.iso_k_line.KLineMessage.checksum_good">
<code class="descname">checksum_good</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineMessage.checksum_good" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate the message checksum</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A bool that is true when checksum is valid.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.iso_k_line.KLineMessage.end_time">
<code class="descname">end_time</code><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineMessage.end_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ripyl.protocol.iso_k_line.KLineMessage.raw_data">
<code class="descname">raw_data</code><span class="sig-paren">(</span><em>full_message=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineMessage.raw_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the raw data for the message</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>full_message</strong> (<em>bool</em>) – </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Complete message including header and checksum when true</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of bytes.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.iso_k_line.KLineMessage.start_time">
<code class="descname">start_time</code><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineMessage.start_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.iso_k_line.KLineProtocol">
<em class="property">class </em><code class="descclassname">ripyl.protocol.iso_k_line.</code><code class="descname">KLineProtocol</code><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineProtocol" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><code class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></code></a></p>
<p>Enumeration for identifying the message protocol</p>
<dl class="attribute">
<dt id="ripyl.protocol.iso_k_line.KLineProtocol.ISO14230">
<code class="descname">ISO14230</code><em class="property"> = 2</em><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineProtocol.ISO14230" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.iso_k_line.KLineProtocol.ISO9141">
<code class="descname">ISO9141</code><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineProtocol.ISO9141" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.iso_k_line.KLineProtocol.Unknown">
<code class="descname">Unknown</code><em class="property"> = 0</em><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineProtocol.Unknown" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.iso_k_line.KLineStreamMessage">
<em class="property">class </em><code class="descclassname">ripyl.protocol.iso_k_line.</code><code class="descname">KLineStreamMessage</code><span class="sig-paren">(</span><em>msg</em>, <em>status=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineStreamMessage" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.protocol.obd2.OBD2StreamMessage" title="ripyl.protocol.obd2.OBD2StreamMessage"><code class="xref py py-class docutils literal"><span class="pre">ripyl.protocol.obd2.OBD2StreamMessage</span></code></a></p>
<p>StreamMessage object for the K-line protocols ISO9141 and ISO14230</p>
<dl class="method">
<dt id="ripyl.protocol.iso_k_line.KLineStreamMessage.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>msg</em>, <em>status=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineStreamMessage.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="ripyl.protocol.iso_k_line.KLineStreamMessage.status_text">
<em class="property">classmethod </em><code class="descname">status_text</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineStreamMessage.status_text" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The string representation of a status code</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.iso_k_line.KLineStreamStatus">
<em class="property">class </em><code class="descclassname">ripyl.protocol.iso_k_line.</code><code class="descname">KLineStreamStatus</code><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineStreamStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><code class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></code></a></p>
<p>Enumeration for KLineStreamMessage status codes</p>
<dl class="attribute">
<dt id="ripyl.protocol.iso_k_line.KLineStreamStatus.BadInitError">
<code class="descname">BadInitError</code><em class="property"> = 202</em><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineStreamStatus.BadInitError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.iso_k_line.KLineStreamStatus.ChecksumError">
<code class="descname">ChecksumError</code><em class="property"> = 201</em><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineStreamStatus.ChecksumError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.iso_k_line.KLineStreamStatus.InvalidMessageError">
<code class="descname">InvalidMessageError</code><em class="property"> = 203</em><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineStreamStatus.InvalidMessageError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.iso_k_line.KLineWakeup">
<em class="property">class </em><code class="descclassname">ripyl.protocol.iso_k_line.</code><code class="descname">KLineWakeup</code><span class="sig-paren">(</span><em>bounds</em>, <em>edges</em>, <em>status=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineWakeup" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><code class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></code></a></p>
<p>Encapsulates BRK data values representing the wakeup pattern</p>
<p>This is used for the slow init (0x33 at 5-baud) and the fast init (25ms low, 25ms high)</p>
<dl class="method">
<dt id="ripyl.protocol.iso_k_line.KLineWakeup.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>bounds</em>, <em>edges</em>, <em>status=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineWakeup.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.iso_k_line.iso_k_line_decode">
<code class="descclassname">ripyl.protocol.iso_k_line.</code><code class="descname">iso_k_line_decode</code><span class="sig-paren">(</span><em>stream_data</em>, <em>min_message_interval=0.007</em>, <em>logic_levels=None</em>, <em>stream_type=1</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.iso_k_line.iso_k_line_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode ISO9141 and ISO14230 data streams</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations.</p>
<p>Sample streams are a sequence of SampleChunk Objects. Edge streams are a sequence
of 2-tuples of (time, int) pairs. The type of stream is identified by the stream_type
parameter. Sample streams will be analyzed to find edge transitions representing
0 and 1 logic states of the waveforms. With sample streams, an initial block of data
is consumed to determine the most likely logic levels in the signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>stream_data</strong> (<em>iterable of SampleChunk objects</em><em> or </em><em>(</em><em>float</em><em>, </em><em>int</em><em>) </em><em>pairs</em>) – A sample stream or edge stream of K-line messages.</li>
<li><strong>min_message_interval</strong> (<em>float</em>) – The minimum time between bytes for identifying the end and start
of messages. For ISO14230 this is used in addition to the message length encoded
in the header.</li>
<li><strong>logic_levels</strong> (<em>(</em><em>float</em><em>, </em><em>float</em><em>) or </em><em>None</em>) – Optional pair that indicates (low, high) logic levels of the sample
stream. When present, auto level detection is disabled. This has no effect on
edge streams.</li>
<li><strong>stream_type</strong> (<a class="reference internal" href="ripyl.html#ripyl.streaming.StreamType" title="ripyl.streaming.StreamType"><em>streaming.StreamType</em></a>) – A StreamType value indicating that the stream parameter represents either Samples
or Edges</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param  :
:param  :
:returns: An iterator yielding  a series of KLineStreamMessage objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">AutoLevelError if stream_type = Samples and the logic levels cannot
be determined.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.iso_k_line.iso_k_line_synth">
<code class="descclassname">ripyl.protocol.iso_k_line.</code><code class="descname">iso_k_line_synth</code><span class="sig-paren">(</span><em>messages</em>, <em>idle_start=0.0</em>, <em>message_interval=0.008</em>, <em>idle_end=0.0</em>, <em>word_interval=0.001</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.iso_k_line.iso_k_line_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate synthesized ISO9141 and ISO14230 data streams</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>messages</strong> (<em>sequence of tuple of int</em>) – Messages to be synthesized. Each element is a tuple of bytes to send
for each message.</li>
<li><strong>idle_start</strong> (<em>float</em>) – The amount of idle time before the transmission of messages begins.</li>
<li><strong>message_interval</strong> (<em>float</em>) – The amount of time between messages.</li>
<li><strong>idle_end</strong> (<em>float</em>) – The amount of idle time after the last message.</li>
<li><strong>word_interval</strong> (<em>float</em>) – The amount of time between message bytes.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  an edge stream of (float, int) pairs. The first element in the iterator
is the initial state of the stream.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.protocol.j1850">
<span id="ripyl-protocol-j1850-module"></span><h2>ripyl.protocol.j1850 module<a class="headerlink" href="#module-ripyl.protocol.j1850" title="Permalink to this headline">¶</a></h2>
<p>J1850 protocol decoder</p>
<dl class="class">
<dt id="ripyl.protocol.j1850.J1850Break">
<em class="property">class </em><code class="descclassname">ripyl.protocol.j1850.</code><code class="descname">J1850Break</code><a class="headerlink" href="#ripyl.protocol.j1850.J1850Break" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Representation of a J1850 break condition</p>
<dl class="method">
<dt id="ripyl.protocol.j1850.J1850Break.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.j1850.J1850Break.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.j1850.J1850Frame">
<em class="property">class </em><code class="descclassname">ripyl.protocol.j1850.</code><code class="descname">J1850Frame</code><span class="sig-paren">(</span><em>priority</em>, <em>msg_type</em>, <em>data</em>, <em>target=None</em>, <em>source=None</em>, <em>ifr_data=None</em>, <em>crc=None</em>, <em>ifr_crc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.j1850.J1850Frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Base class for J1850 frames</p>
<dl class="method">
<dt id="ripyl.protocol.j1850.J1850Frame.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>priority</em>, <em>msg_type</em>, <em>data</em>, <em>target=None</em>, <em>source=None</em>, <em>ifr_data=None</em>, <em>crc=None</em>, <em>ifr_crc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.j1850.J1850Frame.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>priority</strong> (<em>int</em>) – The 3-bit frame priority field. Lower values have higher priority.</li>
<li><strong>msg_type</strong> (<a class="reference internal" href="#ripyl.protocol.j1850.J1850MT" title="ripyl.protocol.j1850.J1850MT"><em>J1850MT</em></a>) – Message type.</li>
<li><strong>data</strong> (<em>sequence of int</em><em> or </em><em>None</em>) – Data bytes for the frame.</li>
<li><strong>target</strong> (<em>int</em>) – Target address or function.</li>
<li><strong>source</strong> (<em>int</em>) – Source address.</li>
<li><strong>ifr_data</strong> (<em>sequence of int</em><em> or </em><em>None</em>) – Optional data for the In-Frame Response.</li>
<li><strong>crc</strong> (<em>int</em><em> or </em><em>None</em>) – CRC for the data bytes and header.</li>
<li><strong>ifr_crc</strong> (<em>int</em><em> or </em><em>None</em>) – CRC for the IFR (FunctionRead message type only)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.j1850.J1850Frame.bytes">
<code class="descname">bytes</code><a class="headerlink" href="#ripyl.protocol.j1850.J1850Frame.bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the bytes for this frame. Does not include IFR.</p>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.j1850.J1850Frame.crc">
<code class="descname">crc</code><a class="headerlink" href="#ripyl.protocol.j1850.J1850Frame.crc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ripyl.protocol.j1850.J1850Frame.crc_is_valid">
<code class="descname">crc_is_valid</code><span class="sig-paren">(</span><em>recv_crc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.j1850.J1850Frame.crc_is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a decoded CRC is valid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>recv_crc</strong> (<em>int</em><em> or </em><em>None</em>) – The decoded CRC to check against. If None, the CRC passed in the constructor is used.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True when the crc is correct.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.j1850.J1850Frame.ifr_bytes">
<code class="descname">ifr_bytes</code><a class="headerlink" href="#ripyl.protocol.j1850.J1850Frame.ifr_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the IFR bytes for this frame.</p>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.j1850.J1850Frame.ifr_crc">
<code class="descname">ifr_crc</code><a class="headerlink" href="#ripyl.protocol.j1850.J1850Frame.ifr_crc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ripyl.protocol.j1850.J1850Frame.ifr_crc_is_valid">
<code class="descname">ifr_crc_is_valid</code><span class="sig-paren">(</span><em>recv_crc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.j1850.J1850Frame.ifr_crc_is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a decoded IFR CRC is valid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>recv_crc</strong> (<em>int</em><em> or </em><em>None</em>) – The decoded CRC to check against. If None, the CRC passed in the constructor is used.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True when the crc is correct.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.j1850.J1850MT">
<em class="property">class </em><code class="descclassname">ripyl.protocol.j1850.</code><code class="descname">J1850MT</code><a class="headerlink" href="#ripyl.protocol.j1850.J1850MT" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><code class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></code></a></p>
<p>Enumeration of J1850 message types (last 4 bits of header byte)</p>
<dl class="attribute">
<dt id="ripyl.protocol.j1850.J1850MT.Ack">
<code class="descname">Ack</code><em class="property"> = 14</em><a class="headerlink" href="#ripyl.protocol.j1850.J1850MT.Ack" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.j1850.J1850MT.Broadcast">
<code class="descname">Broadcast</code><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.j1850.J1850MT.Broadcast" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.j1850.J1850MT.Function">
<code class="descname">Function</code><em class="property"> = 0</em><a class="headerlink" href="#ripyl.protocol.j1850.J1850MT.Function" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.j1850.J1850MT.FunctionCmd">
<code class="descname">FunctionCmd</code><em class="property"> = 8</em><a class="headerlink" href="#ripyl.protocol.j1850.J1850MT.FunctionCmd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.j1850.J1850MT.FunctionExtCmd">
<code class="descname">FunctionExtCmd</code><em class="property"> = 10</em><a class="headerlink" href="#ripyl.protocol.j1850.J1850MT.FunctionExtCmd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.j1850.J1850MT.FunctionExtRqst">
<code class="descname">FunctionExtRqst</code><em class="property"> = 11</em><a class="headerlink" href="#ripyl.protocol.j1850.J1850MT.FunctionExtRqst" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.j1850.J1850MT.FunctionQuery">
<code class="descname">FunctionQuery</code><em class="property"> = 2</em><a class="headerlink" href="#ripyl.protocol.j1850.J1850MT.FunctionQuery" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.j1850.J1850MT.FunctionRead">
<code class="descname">FunctionRead</code><em class="property"> = 3</em><a class="headerlink" href="#ripyl.protocol.j1850.J1850MT.FunctionRead" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.j1850.J1850MT.FunctionRqst">
<code class="descname">FunctionRqst</code><em class="property"> = 9</em><a class="headerlink" href="#ripyl.protocol.j1850.J1850MT.FunctionRqst" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.j1850.J1850MT.NodeToNode">
<code class="descname">NodeToNode</code><em class="property"> = 12</em><a class="headerlink" href="#ripyl.protocol.j1850.J1850MT.NodeToNode" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.j1850.J1850MT.NodeToNodeIFR">
<code class="descname">NodeToNodeIFR</code><em class="property"> = 4</em><a class="headerlink" href="#ripyl.protocol.j1850.J1850MT.NodeToNodeIFR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.j1850.J1850MT.Reserved13">
<code class="descname">Reserved13</code><em class="property"> = 13</em><a class="headerlink" href="#ripyl.protocol.j1850.J1850MT.Reserved13" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.j1850.J1850MT.Reserved15">
<code class="descname">Reserved15</code><em class="property"> = 15</em><a class="headerlink" href="#ripyl.protocol.j1850.J1850MT.Reserved15" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.j1850.J1850MT.Reserved5">
<code class="descname">Reserved5</code><em class="property"> = 5</em><a class="headerlink" href="#ripyl.protocol.j1850.J1850MT.Reserved5" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.j1850.J1850MT.Reserved6">
<code class="descname">Reserved6</code><em class="property"> = 6</em><a class="headerlink" href="#ripyl.protocol.j1850.J1850MT.Reserved6" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.j1850.J1850MT.Reserved7">
<code class="descname">Reserved7</code><em class="property"> = 7</em><a class="headerlink" href="#ripyl.protocol.j1850.J1850MT.Reserved7" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.j1850.J1850StreamFrame">
<em class="property">class </em><code class="descclassname">ripyl.protocol.j1850.</code><code class="descname">J1850StreamFrame</code><span class="sig-paren">(</span><em>bounds</em>, <em>frame</em>, <em>status=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.j1850.J1850StreamFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><code class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></code></a></p>
<p>Encapsulates a J1850Frame object into a StreamSegment</p>
<dl class="method">
<dt id="ripyl.protocol.j1850.J1850StreamFrame.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>bounds</em>, <em>frame</em>, <em>status=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.j1850.J1850StreamFrame.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.j1850.J1850StreamStatus">
<em class="property">class </em><code class="descclassname">ripyl.protocol.j1850.</code><code class="descname">J1850StreamStatus</code><a class="headerlink" href="#ripyl.protocol.j1850.J1850StreamStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><code class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></code></a></p>
<p>Enumeration for J1850StreamFrame status codes</p>
<dl class="attribute">
<dt id="ripyl.protocol.j1850.J1850StreamStatus.CRCError">
<code class="descname">CRCError</code><em class="property"> = 201</em><a class="headerlink" href="#ripyl.protocol.j1850.J1850StreamStatus.CRCError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.j1850.VPWNormBitStyle">
<em class="property">class </em><code class="descclassname">ripyl.protocol.j1850.</code><code class="descname">VPWNormBitStyle</code><a class="headerlink" href="#ripyl.protocol.j1850.VPWNormBitStyle" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><code class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></code></a></p>
<p>Enumeration of VPW normalization bit coding scheme</p>
<dl class="attribute">
<dt id="ripyl.protocol.j1850.VPWNormBitStyle.GM">
<code class="descname">GM</code><em class="property"> = 2</em><a class="headerlink" href="#ripyl.protocol.j1850.VPWNormBitStyle.GM" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.j1850.VPWNormBitStyle.SAE">
<code class="descname">SAE</code><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.j1850.VPWNormBitStyle.SAE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.j1850.j1850_pwm_decode">
<code class="descclassname">ripyl.protocol.j1850.</code><code class="descname">j1850_pwm_decode</code><span class="sig-paren">(</span><em>pwm</em>, <em>logic_levels=None</em>, <em>stream_type=1</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.j1850.j1850_pwm_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode a J1850 PWM data stream</p>
<p>This decodes the Pulse Width Modulated version of J1850 (Ford).</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations.</p>
<p>Sample streams are a sequence of SampleChunk Objects. Edge streams are a sequence
of 2-tuples of (time, int) pairs. The type of stream is identified by the stream_type
parameter. Sample streams will be analyzed to find edge transitions representing
0 and 1 logic states of the waveforms. With sample streams, an initial block of data
is consumed to determine the most likely logic levels in the signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pwm</strong> (<em>iterable of SampleChunk objects</em><em> or </em><em>(</em><em>float</em><em>, </em><em>int</em><em>) </em><em>pairs</em>) – A sample stream or edge stream representing a PWM Bus+ signal or the differential
Bus+ - Bus-.</li>
<li><strong>logic_levels</strong> (<em>(</em><em>float</em><em>, </em><em>float</em><em>) or </em><em>None</em>) – Optional pair that indicates (low, high) logic levels of the sample
stream. When present, auto level detection is disabled. This has no effect on
edge streams.</li>
<li><strong>stream_type</strong> (<a class="reference internal" href="ripyl.html#ripyl.streaming.StreamType" title="ripyl.streaming.StreamType"><em>streaming.StreamType</em></a>) – A StreamType value indicating that the can parameter represents either Samples
or Edges</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An iterator yielding  a series of J1850StreamFrame objects. Each frame contains subrecords marking the location
of sub-elements within the frame. CRC errors are recorded as an error status in their
respective subrecords.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">AutoLevelError if stream_type = Samples and the logic levels cannot
be determined.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.j1850.j1850_pwm_synth">
<code class="descclassname">ripyl.protocol.j1850.</code><code class="descname">j1850_pwm_synth</code><span class="sig-paren">(</span><em>frames</em>, <em>breaks=None</em>, <em>idle_start=0.0</em>, <em>frame_interval=0.0</em>, <em>idle_end=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.j1850.j1850_pwm_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate synthesized J1850 PWM data streams</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>frames</strong> (<em>sequence of J1850Frame</em><em> or </em><a class="reference internal" href="#ripyl.protocol.j1850.J1850Break" title="ripyl.protocol.j1850.J1850Break"><em>J1850Break</em></a>) – Frames to be synthesized.</li>
<li><strong>breaks</strong> (<em>sequence of</em><em> (</em><em>int</em><em>, </em><em>float</em><em>)</em>) – A set of tuples that identify which frames are interrupted by a break condition.
The first int portion of the tuple identifies the frame index and the second float
is the percentage (0.0 to 1.0) of the total frame that is generated before the break.</li>
<li><strong>idle_start</strong> (<em>float</em>) – The amount of idle time before the transmission of frames begins.</li>
<li><strong>frame_interval</strong> (<em>float</em>) – The amount of time between frames.</li>
<li><strong>idle_end</strong> (<em>float</em>) – The amount of idle time after the last frame.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  an edge stream of (float, int) pairs. The first element in the iterator
is the initial state of the stream.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.j1850.j1850_vpw_decode">
<code class="descclassname">ripyl.protocol.j1850.</code><code class="descname">j1850_vpw_decode</code><span class="sig-paren">(</span><em>vpw</em>, <em>norm_bit=1</em>, <em>logic_levels=None</em>, <em>stream_type=1</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.j1850.j1850_vpw_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode a J1850 VPW data stream</p>
<p>This decodes the Variable Pulse Width version of J1850 (GM &amp; Chrysler).</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations.</p>
<p>Sample streams are a sequence of SampleChunk Objects. Edge streams are a sequence
of 2-tuples of (time, int) pairs. The type of stream is identified by the stream_type
parameter. Sample streams will be analyzed to find edge transitions representing
0 and 1 logic states of the waveforms. With sample streams, an initial block of data
is consumed to determine the most likely logic levels in the signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>vpw</strong> (<em>iterable of SampleChunk objects</em><em> or </em><em>(</em><em>float</em><em>, </em><em>int</em><em>) </em><em>pairs</em>) – A sample stream or edge stream representing a VPW data signal.</li>
<li><strong>norm_bit</strong> (<a class="reference internal" href="#ripyl.protocol.j1850.VPWNormBitStyle" title="ripyl.protocol.j1850.VPWNormBitStyle"><em>VPWNormBitStyle</em></a>) – How to interpret the normalization bit for In-Frame Response. Either standard SAE
style or the GM specific variant. This determines whether the IFR is expected to
have a CRC independently from the message type.</li>
<li><strong>logic_levels</strong> (<em>(</em><em>float</em><em>, </em><em>float</em><em>) or </em><em>None</em>) – Optional pair that indicates (low, high) logic levels of the sample
stream. When present, auto level detection is disabled. This has no effect on
edge streams.</li>
<li><strong>stream_type</strong> (<a class="reference internal" href="ripyl.html#ripyl.streaming.StreamType" title="ripyl.streaming.StreamType"><em>streaming.StreamType</em></a>) – A StreamType value indicating that the can parameter represents either Samples
or Edges</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An iterator yielding  a series of J1850StreamFrame objects. Each frame contains subrecords marking the location
of sub-elements within the frame. CRC errors are recorded as an error status in their
respective subrecords.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">AutoLevelError if stream_type = Samples and the logic levels cannot
be determined.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.j1850.j1850_vpw_synth">
<code class="descclassname">ripyl.protocol.j1850.</code><code class="descname">j1850_vpw_synth</code><span class="sig-paren">(</span><em>frames</em>, <em>norm_bit=1</em>, <em>breaks=None</em>, <em>idle_start=0.0</em>, <em>frame_interval=0.0</em>, <em>idle_end=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.j1850.j1850_vpw_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate synthesized J1850 VPW data streams</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>frames</strong> (<em>sequence of J1850Frame</em><em> or </em><a class="reference internal" href="#ripyl.protocol.j1850.J1850Break" title="ripyl.protocol.j1850.J1850Break"><em>J1850Break</em></a>) – Frames to be synthesized.</li>
<li><strong>norm_bit</strong> (<a class="reference internal" href="#ripyl.protocol.j1850.VPWNormBitStyle" title="ripyl.protocol.j1850.VPWNormBitStyle"><em>VPWNormBitStyle</em></a>) – How to interpret the normalization bit for In-Frame Response. Either standard SAE
style or the GM specific variant. This determines whether the IFR is expected to
have a CRC independently from the message type.</li>
<li><strong>breaks</strong> (<em>sequence of</em><em> (</em><em>int</em><em>, </em><em>float</em><em>)</em>) – A set of tuples that identify which frames are interrupted by a break condition.
The first int portion of the tuple identifies the frame index and the second float
is the percentage (0.0 to 1.0) of the total frame that is generated before the break.</li>
<li><strong>idle_start</strong> (<em>float</em>) – The amount of idle time before the transmission of frames begins.</li>
<li><strong>frame_interval</strong> (<em>float</em>) – The amount of time between frames.</li>
<li><strong>idle_end</strong> (<em>float</em>) – The amount of idle time after the last frame.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  an edge stream of (float, int) pairs. The first element in the iterator
is the initial state of the stream.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.j1850.pwm_encode">
<code class="descclassname">ripyl.protocol.j1850.</code><code class="descname">pwm_encode</code><span class="sig-paren">(</span><em>bytes</em>, <em>start_time</em>, <em>bit_slice</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.j1850.pwm_encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert bytes to a PWM edge sequence</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>bytes</strong> (<em>sequence of int</em>) – The bytes to encode</li>
<li><strong>start_time</strong> (<em>float</em>) – The Start time for the first edge</li>
<li><strong>bit_slice</strong> (<em>float</em>) – The time for 1/3 of a bit period.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of (float, int) edge pairs.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.j1850.single_to_diff">
<code class="descclassname">ripyl.protocol.j1850.</code><code class="descname">single_to_diff</code><span class="sig-paren">(</span><em>signal</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.j1850.single_to_diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a single-ended edge stream to a differential pair</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>signal</strong> (<em>edge stream</em>) – The edges to convert to differential</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A pair of edge streams p and m representing the + and - differential pair.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.j1850.table_j1850_crc8">
<code class="descclassname">ripyl.protocol.j1850.</code><code class="descname">table_j1850_crc8</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.j1850.table_j1850_crc8" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate J1850 CRC-8 on data</p>
<p>This is a table-based byte-wise implementation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>d</strong> (<em>sequence of int</em>) – Array of integers representing bytes</td>
</tr>
</tbody>
</table>
<p>:param  :
:returns: An integer with the crc value.</p>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.j1850.vpw_encode">
<code class="descclassname">ripyl.protocol.j1850.</code><code class="descname">vpw_encode</code><span class="sig-paren">(</span><em>bytes</em>, <em>start_time</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.j1850.vpw_encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert bytes to a VPW edge sequence</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>bytes</strong> (<em>sequence of int</em>) – The bytes to encode</li>
<li><strong>start_time</strong> (<em>float</em>) – The Start time for the first edge</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of (float, int) edge pairs.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.protocol.lin">
<span id="ripyl-protocol-lin-module"></span><h2>ripyl.protocol.lin module<a class="headerlink" href="#module-ripyl.protocol.lin" title="Permalink to this headline">¶</a></h2>
<p>LIN protocol decoder</p>
<dl class="class">
<dt id="ripyl.protocol.lin.LINChecksum">
<em class="property">class </em><code class="descclassname">ripyl.protocol.lin.</code><code class="descname">LINChecksum</code><a class="headerlink" href="#ripyl.protocol.lin.LINChecksum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><code class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></code></a></p>
<p>Enumeration for LIN checksum type</p>
<dl class="attribute">
<dt id="ripyl.protocol.lin.LINChecksum.Classic">
<code class="descname">Classic</code><em class="property"> = 0</em><a class="headerlink" href="#ripyl.protocol.lin.LINChecksum.Classic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.lin.LINChecksum.Enhanced">
<code class="descname">Enhanced</code><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.lin.LINChecksum.Enhanced" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.lin.LINFrame">
<em class="property">class </em><code class="descclassname">ripyl.protocol.lin.</code><code class="descname">LINFrame</code><span class="sig-paren">(</span><em>id</em>, <em>data=None</em>, <em>checksum=None</em>, <em>pid_parity=None</em>, <em>cs_type=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.lin.LINFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>LIN frame object</p>
<dl class="method">
<dt id="ripyl.protocol.lin.LINFrame.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>id</em>, <em>data=None</em>, <em>checksum=None</em>, <em>pid_parity=None</em>, <em>cs_type=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.lin.LINFrame.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>id</strong> (<em>int</em>) – The ID field from the PID</li>
<li><strong>data</strong> (<em>sequence of int</em><em> or </em><em>None</em>) – Optional sequence of data bytes for the frame. Should be between 1 and 8 bytes long.
An empty list is converted to None.</li>
<li><strong>checksum</strong> (<em>int</em><em> or </em><em>None</em>) – Optional checksum for the frame</li>
<li><strong>pid_parity</strong> (<em>int</em><em> or </em><em>None</em>) – Optional parity bits from the PID field</li>
<li><strong>cs_type</strong> (<a class="reference internal" href="#ripyl.protocol.lin.LINChecksum" title="ripyl.protocol.lin.LINChecksum"><em>LINChecksum</em></a>) – The checksum type to use for this frame</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.lin.LINFrame.bytes">
<code class="descname">bytes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.lin.LINFrame.bytes" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A sequence of raw frame bytes including the sync field</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.lin.LINFrame.checksum">
<code class="descname">checksum</code><a class="headerlink" href="#ripyl.protocol.lin.LINFrame.checksum" title="Permalink to this definition">¶</a></dt>
<dd><p>The frame checksum</p>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.lin.LINFrame.checksum_is_valid">
<code class="descname">checksum_is_valid</code><span class="sig-paren">(</span><em>recv_cs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.lin.LINFrame.checksum_is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the checksum is valid</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>recv_cs</strong> (<em>int</em><em> or </em><em>None</em>) – Optional received checksum value. If None, the stored checksum
for the frame is used instead.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.lin.LINFrame.data_checksum">
<code class="descname">data_checksum</code><a class="headerlink" href="#ripyl.protocol.lin.LINFrame.data_checksum" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the checksum over the data bytes without reference to any existing _checksum value</p>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.lin.LINFrame.pid">
<code class="descname">pid</code><a class="headerlink" href="#ripyl.protocol.lin.LINFrame.pid" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the frame PID</p>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.lin.LINFrame.pid_is_valid">
<code class="descname">pid_is_valid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.lin.LINFrame.pid_is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the PID parity bits are correct</p>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.lin.LINFrame.pid_parity">
<code class="descname">pid_parity</code><a class="headerlink" href="#ripyl.protocol.lin.LINFrame.pid_parity" title="Permalink to this definition">¶</a></dt>
<dd><p>The parity bits from the PID</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.lin.LINStreamFrame">
<em class="property">class </em><code class="descclassname">ripyl.protocol.lin.</code><code class="descname">LINStreamFrame</code><span class="sig-paren">(</span><em>bounds</em>, <em>frame</em>, <em>status=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.lin.LINStreamFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><code class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></code></a></p>
<p>Encapsulates a LINFrame object into a StreamSegment</p>
<dl class="method">
<dt id="ripyl.protocol.lin.LINStreamFrame.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>bounds</em>, <em>frame</em>, <em>status=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.lin.LINStreamFrame.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.lin.LINStreamStatus">
<em class="property">class </em><code class="descclassname">ripyl.protocol.lin.</code><code class="descname">LINStreamStatus</code><a class="headerlink" href="#ripyl.protocol.lin.LINStreamStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><code class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></code></a></p>
<p>Enumeration for LINStreamFrame status codes</p>
<dl class="attribute">
<dt id="ripyl.protocol.lin.LINStreamStatus.ChecksumError">
<code class="descname">ChecksumError</code><em class="property"> = 202</em><a class="headerlink" href="#ripyl.protocol.lin.LINStreamStatus.ChecksumError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.lin.LINStreamStatus.PIDError">
<code class="descname">PIDError</code><em class="property"> = 201</em><a class="headerlink" href="#ripyl.protocol.lin.LINStreamStatus.PIDError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.lin.lin_checksum">
<code class="descclassname">ripyl.protocol.lin.</code><code class="descname">lin_checksum</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.lin.lin_checksum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the LIN checksum</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>sequence of int</em>) – The bytes (including ID if enhanced format) to compute the checksum over</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The checksum as an int.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.lin.lin_decode">
<code class="descclassname">ripyl.protocol.lin.</code><code class="descname">lin_decode</code><span class="sig-paren">(</span><em>stream_data</em>, <em>enhanced_ids=None</em>, <em>baud_rate=None</em>, <em>logic_levels=None</em>, <em>stream_type=1</em>, <em>param_info=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.lin.lin_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode a LIN data stream</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations.</p>
<p>Sample streams are a sequence of SampleChunk Objects. Edge streams are a sequence
of 2-tuples of (time, int) pairs. The type of stream is identified by the stream_type
parameter. Sample streams will be analyzed to find edge transitions representing
0 and 1 logic states of the waveforms. With sample streams, an initial block of data
is consumed to determine the most likely logic levels in the signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>stream_data</strong> (<em>iterable of SampleChunk objects</em><em> or </em><em>(</em><em>float</em><em>, </em><em>int</em><em>) </em><em>pairs</em>) – A sample stream or edge stream representing a LIN signal.</li>
<li><strong>enhanced_ids</strong> (<em>sequence of int</em><em> or </em><em>None</em>) – An optional sequence of frame IDs that are to use LIN 2.x enhanced checksums.
If None, the checksum type is guessed by trying both methods to see if one matches
decoded checksum.</li>
<li><strong>baud_rate</strong> (<em>int</em><em> or </em><em>None</em>) – The baud rate of the stream. If None, the first 50 edges will be analyzed to
automatically determine the most likely baud rate for the stream. On average
50 edges will occur after 11 bytes have been captured.</li>
<li><strong>logic_levels</strong> (<em>(</em><em>float</em><em>, </em><em>float</em><em>) or </em><em>None</em>) – Optional pair that indicates (low, high) logic levels of the sample
stream. When present, auto level detection is disabled. This has no effect on
edge streams.</li>
<li><strong>stream_type</strong> (<a class="reference internal" href="ripyl.html#ripyl.streaming.StreamType" title="ripyl.streaming.StreamType"><em>streaming.StreamType</em></a>) – A StreamType value indicating that the stream parameter represents either Samples
or Edges</li>
<li><strong>param_info</strong> (<em>dict</em><em> or </em><em>None</em>) – An optional dictionary object that is used to monitor the results of
automatic baud detection.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param  :
:param  :
:returns: An iterator yielding  a series of LINStreamFrame objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">AutoLevelError if stream_type = Samples and the logic levels cannot
be determined.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">AutoBaudError if auto-baud is active and the baud rate cannot
be determined.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.lin.lin_pid">
<code class="descclassname">ripyl.protocol.lin.</code><code class="descname">lin_pid</code><span class="sig-paren">(</span><em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.lin.lin_pid" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a LIN PID from an ID</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>id</strong> (<em>int</em>) – The ID to generate parity for</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The pid as an int.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.lin.lin_synth">
<code class="descclassname">ripyl.protocol.lin.</code><code class="descname">lin_synth</code><span class="sig-paren">(</span><em>frames</em>, <em>baud</em>, <em>idle_start=0.0</em>, <em>frame_interval=0.008</em>, <em>idle_end=0.0</em>, <em>byte_interval=0.001</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.lin.lin_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate synthesized LIN data streams</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>frames</strong> (<em>sequence of LINFrame</em>) – Frames to be synthesized.</li>
<li><strong>baud</strong> (<em>int</em>) – The baud rate.</li>
<li><strong>idle_start</strong> (<em>float</em>) – The amount of idle time before the transmission of messages begins.</li>
<li><strong>frame_interval</strong> (<em>float</em>) – The amount of time between frames.</li>
<li><strong>idle_end</strong> (<em>float</em>) – The amount of idle time after the last message.</li>
<li><strong>byte_interval</strong> (<em>float</em>) – The amount of time between message bytes.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  an edge stream of (float, int) pairs. The first element in the iterator
is the initial state of the stream.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.protocol.lm73">
<span id="ripyl-protocol-lm73-module"></span><h2>ripyl.protocol.lm73 module<a class="headerlink" href="#module-ripyl.protocol.lm73" title="Permalink to this headline">¶</a></h2>
<p>LM73 (temperature sensor) protocol decoder</p>
<dl class="class">
<dt id="ripyl.protocol.lm73.LM73Operation">
<em class="property">class </em><code class="descclassname">ripyl.protocol.lm73.</code><code class="descname">LM73Operation</code><a class="headerlink" href="#ripyl.protocol.lm73.LM73Operation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><code class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></code></a></p>
<p>Enumeration for LM73 bus operations</p>
<dl class="attribute">
<dt id="ripyl.protocol.lm73.LM73Operation.ReadData">
<code class="descname">ReadData</code><em class="property"> = 2</em><a class="headerlink" href="#ripyl.protocol.lm73.LM73Operation.ReadData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.lm73.LM73Operation.SetPointer">
<code class="descname">SetPointer</code><em class="property"> = 0</em><a class="headerlink" href="#ripyl.protocol.lm73.LM73Operation.SetPointer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.lm73.LM73Operation.WriteData">
<code class="descname">WriteData</code><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.lm73.LM73Operation.WriteData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.lm73.LM73Register">
<em class="property">class </em><code class="descclassname">ripyl.protocol.lm73.</code><code class="descname">LM73Register</code><a class="headerlink" href="#ripyl.protocol.lm73.LM73Register" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><code class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></code></a></p>
<p>Enumeration for LM73 registers</p>
<dl class="attribute">
<dt id="ripyl.protocol.lm73.LM73Register.Configuration">
<code class="descname">Configuration</code><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.lm73.LM73Register.Configuration" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.lm73.LM73Register.ControlStatus">
<code class="descname">ControlStatus</code><em class="property"> = 4</em><a class="headerlink" href="#ripyl.protocol.lm73.LM73Register.ControlStatus" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.lm73.LM73Register.Identification">
<code class="descname">Identification</code><em class="property"> = 7</em><a class="headerlink" href="#ripyl.protocol.lm73.LM73Register.Identification" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.lm73.LM73Register.THigh">
<code class="descname">THigh</code><em class="property"> = 2</em><a class="headerlink" href="#ripyl.protocol.lm73.LM73Register.THigh" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.lm73.LM73Register.TLow">
<code class="descname">TLow</code><em class="property"> = 3</em><a class="headerlink" href="#ripyl.protocol.lm73.LM73Register.TLow" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.lm73.LM73Register.Temperature">
<code class="descname">Temperature</code><em class="property"> = 0</em><a class="headerlink" href="#ripyl.protocol.lm73.LM73Register.Temperature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.lm73.LM73StreamStatus">
<em class="property">class </em><code class="descclassname">ripyl.protocol.lm73.</code><code class="descname">LM73StreamStatus</code><a class="headerlink" href="#ripyl.protocol.lm73.LM73StreamStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><code class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></code></a></p>
<p>Enumeration of LM73 status codes</p>
<dl class="attribute">
<dt id="ripyl.protocol.lm73.LM73StreamStatus.MissingDataError">
<code class="descname">MissingDataError</code><em class="property"> = 201</em><a class="headerlink" href="#ripyl.protocol.lm73.LM73StreamStatus.MissingDataError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.lm73.LM73Transfer">
<em class="property">class </em><code class="descclassname">ripyl.protocol.lm73.</code><code class="descname">LM73Transfer</code><span class="sig-paren">(</span><em>address</em>, <em>op</em>, <em>reg=0</em>, <em>data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.lm73.LM73Transfer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamRecord" title="ripyl.streaming.StreamRecord"><code class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamRecord</span></code></a></p>
<p>Represent a transaction for the LM73</p>
<dl class="method">
<dt id="ripyl.protocol.lm73.LM73Transfer.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>address</em>, <em>op</em>, <em>reg=0</em>, <em>data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.lm73.LM73Transfer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>address</strong> (<em>int</em>) – Address of the transfer</td>
</tr>
</tbody>
</table>
<p>:param  :
:type op: LM73Operation
:param op:</p>
<blockquote>
<div>The operation for this transfer</div></blockquote>
<p>:param  :
:type reg: LM73Register
:param reg:</p>
<blockquote>
<div>The register used in this transfer</div></blockquote>
<p>:param  :
:type data: sequence of ints
:param data:</p>
<blockquote>
<div>List of bytes read/written in the transfer</div></blockquote>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.lm73.LM73Transfer.end_time">
<code class="descname">end_time</code><a class="headerlink" href="#ripyl.protocol.lm73.LM73Transfer.end_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.lm73.LM73Transfer.i2c_tfer">
<code class="descname">i2c_tfer</code><a class="headerlink" href="#ripyl.protocol.lm73.LM73Transfer.i2c_tfer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.lm73.LM73Transfer.start_time">
<code class="descname">start_time</code><a class="headerlink" href="#ripyl.protocol.lm73.LM73Transfer.start_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.lm73.LM73Transfer.temperature">
<code class="descname">temperature</code><a class="headerlink" href="#ripyl.protocol.lm73.LM73Transfer.temperature" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the temperature in Celcius</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A float</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.lm73.convert_temp">
<code class="descclassname">ripyl.protocol.lm73.</code><code class="descname">convert_temp</code><span class="sig-paren">(</span><em>temperature</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.lm73.convert_temp" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a temperature to the LM73 encoding</p>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.lm73.lm73_decode">
<code class="descclassname">ripyl.protocol.lm73.</code><code class="descname">lm73_decode</code><span class="sig-paren">(</span><em>i2c_stream</em>, <em>addresses=set([72</em>, <em>73</em>, <em>74</em>, <em>76</em>, <em>77</em>, <em>78])</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.lm73.lm73_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode an LM73 data stream</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>i2c_stream</strong> (<em>sequence of StreamRecord</em><em> or </em><a class="reference internal" href="#ripyl.protocol.i2c.I2CTransfer" title="ripyl.protocol.i2c.I2CTransfer"><em>I2CTransfer</em></a>) – An iterable representing either a stream of I2C StreamRecord objects or
I2CTransfer objects produced by i2c_decode() or reconstruct_i2c_transfers() respectively.</li>
<li><strong>addresses</strong> (<em>set of ints</em>) – A collection identifying the valid LM73 addresses to decode. All others are ignored.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param  :
:returns: An iterator yielding  a series of LM73Transfer objects and any unrelated I2CTransfer objects.</p>
</dd></dl>

</div>
<div class="section" id="module-ripyl.protocol.obd2">
<span id="ripyl-protocol-obd2-module"></span><h2>ripyl.protocol.obd2 module<a class="headerlink" href="#module-ripyl.protocol.obd2" title="Permalink to this headline">¶</a></h2>
<p>OBD-2 protocol support</p>
<dl class="class">
<dt id="ripyl.protocol.obd2.OBD2Message">
<em class="property">class </em><code class="descclassname">ripyl.protocol.obd2.</code><code class="descname">OBD2Message</code><span class="sig-paren">(</span><em>msg_type</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.obd2.OBD2Message" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Abstract base class for OBD-2 messages</p>
<p>This is to be specialized in each protocol implementation.</p>
<dl class="method">
<dt id="ripyl.protocol.obd2.OBD2Message.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>msg_type</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.obd2.OBD2Message.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ripyl.protocol.obd2.OBD2Message.checksum_good">
<code class="descname">checksum_good</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.obd2.OBD2Message.checksum_good" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate the message checksum</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A bool that is true when checksum is valid.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.obd2.OBD2Message.end_time">
<code class="descname">end_time</code><a class="headerlink" href="#ripyl.protocol.obd2.OBD2Message.end_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Message end time</p>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.obd2.OBD2Message.raw_data">
<code class="descname">raw_data</code><span class="sig-paren">(</span><em>full_message=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.obd2.OBD2Message.raw_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the raw data for the message</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>full_message</strong> (<em>bool</em>) – </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Complete message including header and checksum when true</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of bytes.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.obd2.OBD2Message.start_time">
<code class="descname">start_time</code><a class="headerlink" href="#ripyl.protocol.obd2.OBD2Message.start_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Message start time</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.obd2.OBD2MsgType">
<em class="property">class </em><code class="descclassname">ripyl.protocol.obd2.</code><code class="descname">OBD2MsgType</code><a class="headerlink" href="#ripyl.protocol.obd2.OBD2MsgType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><code class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></code></a></p>
<p>Enumeration for message types</p>
<dl class="attribute">
<dt id="ripyl.protocol.obd2.OBD2MsgType.Request">
<code class="descname">Request</code><em class="property"> = 0</em><a class="headerlink" href="#ripyl.protocol.obd2.OBD2MsgType.Request" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.obd2.OBD2MsgType.Response">
<code class="descname">Response</code><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.obd2.OBD2MsgType.Response" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.obd2.OBD2MsgType.Unknown">
<code class="descname">Unknown</code><em class="property"> = 2</em><a class="headerlink" href="#ripyl.protocol.obd2.OBD2MsgType.Unknown" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.obd2.OBD2StreamMessage">
<em class="property">class </em><code class="descclassname">ripyl.protocol.obd2.</code><code class="descname">OBD2StreamMessage</code><span class="sig-paren">(</span><em>msg</em>, <em>status=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.obd2.OBD2StreamMessage" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><code class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></code></a></p>
<p>Encapsulates an OBD2Message object into a StreamSegment</p>
<dl class="method">
<dt id="ripyl.protocol.obd2.OBD2StreamMessage.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>msg</em>, <em>status=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.obd2.OBD2StreamMessage.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>bounds</strong> (<em>(</em><em>float</em><em>, </em><em>float</em><em>)</em>) – 2-tuple (start_time, end_time) for the packet</td>
</tr>
</tbody>
</table>
<p>:param  :
:type msg: OBD2Message
:param msg:</p>
<blockquote>
<div>OBD2Message object to wrap in a StreamSegment</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>status</strong> (<em>int</em>) – Status code for the packet</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.obd2.OBD2StreamMessage.end_time">
<code class="descname">end_time</code><a class="headerlink" href="#ripyl.protocol.obd2.OBD2StreamMessage.end_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Message end time</p>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.obd2.OBD2StreamMessage.msg">
<code class="descname">msg</code><a class="headerlink" href="#ripyl.protocol.obd2.OBD2StreamMessage.msg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.obd2.OBD2StreamMessage.start_time">
<code class="descname">start_time</code><a class="headerlink" href="#ripyl.protocol.obd2.OBD2StreamMessage.start_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Message start time</p>
</dd></dl>

<dl class="classmethod">
<dt id="ripyl.protocol.obd2.OBD2StreamMessage.status_text">
<em class="property">classmethod </em><code class="descname">status_text</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.obd2.OBD2StreamMessage.status_text" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.obd2.OBD2StreamTransfer">
<em class="property">class </em><code class="descclassname">ripyl.protocol.obd2.</code><code class="descname">OBD2StreamTransfer</code><span class="sig-paren">(</span><em>messages</em>, <em>status=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.obd2.OBD2StreamTransfer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><code class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></code></a></p>
<p>Represent a collection of messages involved in a request/response transaction.</p>
<dl class="method">
<dt id="ripyl.protocol.obd2.OBD2StreamTransfer.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>messages</em>, <em>status=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.obd2.OBD2StreamTransfer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>messages</strong> (<em>sequence of OBD2StreamMessage</em>) – A sequence of OBD2StreamMessage objects that form a transfer</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.obd2.OBD2StreamTransfer.end_time">
<code class="descname">end_time</code><a class="headerlink" href="#ripyl.protocol.obd2.OBD2StreamTransfer.end_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.obd2.OBD2StreamTransfer.start_time">
<code class="descname">start_time</code><a class="headerlink" href="#ripyl.protocol.obd2.OBD2StreamTransfer.start_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.obd2.PIDTableEntry">
<em class="property">class </em><code class="descclassname">ripyl.protocol.obd2.</code><code class="descname">PIDTableEntry</code><span class="sig-paren">(</span><em>bytes_returned</em>, <em>description</em>, <em>units=''</em>, <em>decoder=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.obd2.PIDTableEntry" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Data structure for string PID decode info</p>
<dl class="method">
<dt id="ripyl.protocol.obd2.PIDTableEntry.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>bytes_returned</em>, <em>description</em>, <em>units=''</em>, <em>decoder=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.obd2.PIDTableEntry.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.obd2.PTE">
<code class="descclassname">ripyl.protocol.obd2.</code><code class="descname">PTE</code><a class="headerlink" href="#ripyl.protocol.obd2.PTE" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#ripyl.protocol.obd2.PIDTableEntry" title="ripyl.protocol.obd2.PIDTableEntry"><code class="xref py py-class docutils literal"><span class="pre">PIDTableEntry</span></code></a></p>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.obd2.decode_dtc">
<code class="descclassname">ripyl.protocol.obd2.</code><code class="descname">decode_dtc</code><span class="sig-paren">(</span><em>dtc</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.obd2.decode_dtc" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert encoded DTC to a string</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dtc</strong> (<em>int</em>) – The binary coded DTC.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A string representing the dtc in readable form.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.obd2.decode_obd2_command">
<code class="descclassname">ripyl.protocol.obd2.</code><code class="descname">decode_obd2_command</code><span class="sig-paren">(</span><em>msg_type</em>, <em>raw_data</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.obd2.decode_obd2_command" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode the contents of an OBD-2 message</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>msg_type</strong> (<a class="reference internal" href="#ripyl.protocol.obd2.OBD2MsgType" title="ripyl.protocol.obd2.OBD2MsgType"><em>OBD2MsgType</em></a>) – The type of message (request or response) to be decoded.</li>
<li><strong>raw_data</strong> (<em>sequence of ints</em>) – The bytes forming the message</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A 3-tuple containing a string description, a parameter value, and a string for
parameter units. The parameter value is None for request messages and for response
messages with no defined decode routine.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.obd2.reconstruct_obd2_transfers">
<code class="descclassname">ripyl.protocol.obd2.</code><code class="descname">reconstruct_obd2_transfers</code><span class="sig-paren">(</span><em>records</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.obd2.reconstruct_obd2_transfers" title="Permalink to this definition">¶</a></dt>
<dd><p>Aggregate a stream of OBD2StreamMessage objects into OBD2StreamTransfers.</p>
<p>A transfer consists of a request message followed by 0 or more responses from
each ECU on the bus. A new transfer starts with every request message. Objects
other than OBD2StreamMessage are passed through unchanged</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>records</strong> (<em>sequence of OBD2StreamMessage</em>) – The message objects to reconstruct the transfers from.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">An iterator yielding  a stream of OBD2StreamTransfer objects containing aggregated messages
from the input records and any additional non-message stream objects.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.obd2.register_command_decoder">
<code class="descclassname">ripyl.protocol.obd2.</code><code class="descname">register_command_decoder</code><span class="sig-paren">(</span><em>name</em>, <em>func</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.obd2.register_command_decoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a decoder function for additional manufacturer specific SIDs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>string</em>) – The name of the command set to register the decoder under.</li>
<li><strong>func</strong> (<em>function</em><em>(</em><a class="reference internal" href="#ripyl.protocol.obd2.OBD2MsgType" title="ripyl.protocol.obd2.OBD2MsgType"><em>OBD2MsgType</em></a><em>, </em><em>(</em><em>int</em><em>,</em><em>..</em><em>)</em><em>)</em>) – A Python function object that will be called as a command decoder.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.protocol.ps2">
<span id="ripyl-protocol-ps2-module"></span><h2>ripyl.protocol.ps2 module<a class="headerlink" href="#module-ripyl.protocol.ps2" title="Permalink to this headline">¶</a></h2>
<p>PS/2 and AT keyboard protocol decoder</p>
<dl class="class">
<dt id="ripyl.protocol.ps2.PS2Dir">
<em class="property">class </em><code class="descclassname">ripyl.protocol.ps2.</code><code class="descname">PS2Dir</code><a class="headerlink" href="#ripyl.protocol.ps2.PS2Dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><code class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></code></a></p>
<p>Enumeration for PS/2 frame direction</p>
<dl class="attribute">
<dt id="ripyl.protocol.ps2.PS2Dir.DeviceToHost">
<code class="descname">DeviceToHost</code><em class="property"> = 0</em><a class="headerlink" href="#ripyl.protocol.ps2.PS2Dir.DeviceToHost" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.ps2.PS2Dir.HostToDevice">
<code class="descname">HostToDevice</code><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.ps2.PS2Dir.HostToDevice" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.ps2.PS2Frame">
<em class="property">class </em><code class="descclassname">ripyl.protocol.ps2.</code><code class="descname">PS2Frame</code><span class="sig-paren">(</span><em>data</em>, <em>direction=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ps2.PS2Frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Frame object for PS/2 data</p>
<dl class="method">
<dt id="ripyl.protocol.ps2.PS2Frame.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>data</em>, <em>direction=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ps2.PS2Frame.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.ps2.PS2StreamFrame">
<em class="property">class </em><code class="descclassname">ripyl.protocol.ps2.</code><code class="descname">PS2StreamFrame</code><span class="sig-paren">(</span><em>bounds</em>, <em>frame</em>, <em>status=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ps2.PS2StreamFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><code class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></code></a></p>
<p>Streaming frame object for PS/2 data</p>
<dl class="method">
<dt id="ripyl.protocol.ps2.PS2StreamFrame.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>bounds</em>, <em>frame</em>, <em>status=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ps2.PS2StreamFrame.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="ripyl.protocol.ps2.PS2StreamFrame.status_text">
<em class="property">classmethod </em><code class="descname">status_text</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ps2.PS2StreamFrame.status_text" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.ps2.PS2StreamStatus">
<em class="property">class </em><code class="descclassname">ripyl.protocol.ps2.</code><code class="descname">PS2StreamStatus</code><a class="headerlink" href="#ripyl.protocol.ps2.PS2StreamStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><code class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></code></a></p>
<p>Enumeration of PS/2 status codes</p>
<dl class="attribute">
<dt id="ripyl.protocol.ps2.PS2StreamStatus.AckError">
<code class="descname">AckError</code><em class="property"> = 203</em><a class="headerlink" href="#ripyl.protocol.ps2.PS2StreamStatus.AckError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.ps2.PS2StreamStatus.FramingError">
<code class="descname">FramingError</code><em class="property"> = 201</em><a class="headerlink" href="#ripyl.protocol.ps2.PS2StreamStatus.FramingError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.ps2.PS2StreamStatus.ParityError">
<code class="descname">ParityError</code><em class="property"> = 202</em><a class="headerlink" href="#ripyl.protocol.ps2.PS2StreamStatus.ParityError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.ps2.PS2StreamStatus.TimingError">
<code class="descname">TimingError</code><em class="property"> = 204</em><a class="headerlink" href="#ripyl.protocol.ps2.PS2StreamStatus.TimingError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.ps2.ps2_decode">
<code class="descclassname">ripyl.protocol.ps2.</code><code class="descname">ps2_decode</code><span class="sig-paren">(</span><em>clk</em>, <em>data</em>, <em>logic_levels=None</em>, <em>stream_type=1</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ps2.ps2_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode a PS/2 data stream</p>
<p>This is a generator function that can be used in a pipeline of waveform
processing operations.</p>
<p>Sample streams are a sequence of SampleChunk Objects. Edge streams are a sequence
of 2-tuples of (time, int) pairs. The type of stream is identified by the stream_type
parameter. Sample streams will be analyzed to find edge transitions representing
0 and 1 logic states of the waveforms. With sample streams, an initial block of data
on the clk stream is consumed to determine the most likely logic levels in the signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clk</strong> (<em>iterable of SampleChunk objects</em><em> or </em><em>(</em><em>float</em><em>, </em><em>int</em><em>) </em><em>pairs</em>) – A sample stream or edge stream representing a PS/2 clk signal</li>
<li><strong>data</strong> (<em>iterable of SampleChunk objects</em><em> or </em><em>(</em><em>float</em><em>, </em><em>int</em><em>) </em><em>pairs</em>) – A sample stream or edge stream representing a PS/2 data signal.</li>
<li><strong>logic_levels</strong> (<em>(</em><em>float</em><em>, </em><em>float</em><em>) or </em><em>None</em>) – Optional pair that indicates (low, high) logic levels of the sample
stream. When present, auto level detection is disabled. This has no effect on
edge streams.</li>
<li><strong>stream_type</strong> (<a class="reference internal" href="ripyl.html#ripyl.streaming.StreamType" title="ripyl.streaming.StreamType"><em>streaming.StreamType</em></a>) – A StreamType value indicating that the clk and data parameters represent either Samples
or Edges</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An iterator yielding  a series of PS2StreamFrame objects.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">AutoLevelError if stream_type = Samples and the logic levels cannot
be determined.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.ps2.ps2_synth">
<code class="descclassname">ripyl.protocol.ps2.</code><code class="descname">ps2_synth</code><span class="sig-paren">(</span><em>frames</em>, <em>clock_freq</em>, <em>idle_start=0.0</em>, <em>word_interval=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.ps2.ps2_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate synthesized PS/2 waveform</p>
<p>This function simulates a transmission of data over PS/2.</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>frames</strong> (<em>sequence of PS2Frame</em>) – A sequence of PS2Frame objects that will be transmitted serially</li>
<li><strong>clock_freq</strong> (<em>float</em>) – The PS/2 clock frequency. 10kHz - 13KHz typ.</li>
<li><strong>idle_start</strong> (<em>float</em>) – The amount of idle time before the transmission of data begins</li>
<li><strong>word_interval</strong> (<em>float</em>) – The amount of time between data bytes</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a set of pairs representing the two edge streams for clk and data
respectively. Each edge stream pair is in (time, value) format representing the
time and logic value (0 or 1) for each edge transition. The first set of pairs
yielded is the initial state of the waveforms.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.protocol.sagem_ecu">
<span id="ripyl-protocol-sagem-ecu-module"></span><h2>ripyl.protocol.sagem_ecu module<a class="headerlink" href="#module-ripyl.protocol.sagem_ecu" title="Permalink to this headline">¶</a></h2>
<p>Sagem ECU protocol support</p>
<p>This module should be included along with ripyl.protocol.obd2.
The Sagem decode functions will be registered with the OBD-2 decoder
and are accessed through obd2.decode_obd2_command().</p>
<dl class="function">
<dt id="ripyl.protocol.sagem_ecu.decode_sagem_msg">
<code class="descclassname">ripyl.protocol.sagem_ecu.</code><code class="descname">decode_sagem_msg</code><span class="sig-paren">(</span><em>sid</em>, <em>pid_table</em>, <em>pid_size</em>, <em>msg_type</em>, <em>raw_data</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.sagem_ecu.decode_sagem_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode SAGEM message with one or two byte PIDs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sid</strong> (<em>int</em>) – The message SID</li>
<li><strong>pid_table</strong> (<em>dict of PIDTableEntry</em>) – A dict associating PIDs with decode information</li>
<li><strong>pid_size</strong> (<em>int</em>) – The number of bytes in the PID: 1 or 2</li>
<li><strong>msg_type</strong> (<a class="reference internal" href="#ripyl.protocol.obd2.OBD2MsgType" title="ripyl.protocol.obd2.OBD2MsgType"><em>OBD2MsgType</em></a>) – Request or response message</li>
<li><strong>raw_data</strong> (<em>sequence of ints</em>) – Bytes for the message</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.protocol.spi">
<span id="ripyl-protocol-spi-module"></span><h2>ripyl.protocol.spi module<a class="headerlink" href="#module-ripyl.protocol.spi" title="Permalink to this headline">¶</a></h2>
<p>SPI protocol decoder</p>
<dl class="class">
<dt id="ripyl.protocol.spi.SPIFrame">
<em class="property">class </em><code class="descclassname">ripyl.protocol.spi.</code><code class="descname">SPIFrame</code><span class="sig-paren">(</span><em>bounds</em>, <em>data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.spi.SPIFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><code class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></code></a></p>
<p>Frame object for SPI data</p>
<dl class="method">
<dt id="ripyl.protocol.spi.SPIFrame.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>bounds</em>, <em>data=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.spi.SPIFrame.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>bounds</strong> (<em>(</em><em>float</em><em>, </em><em>float</em><em>)</em>) – 2-tuple (start_time, end_time) for the bounds of the frame</li>
<li><strong>data</strong> (<em>sequence of int</em><em> or </em><em>None</em>) – Optional data representing the contents of the frame</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.spi.spi_decode">
<code class="descclassname">ripyl.protocol.spi.</code><code class="descname">spi_decode</code><span class="sig-paren">(</span><em>clk</em>, <em>data_io</em>, <em>cs=None</em>, <em>cpol=0</em>, <em>cpha=0</em>, <em>lsb_first=True</em>, <em>logic_levels=None</em>, <em>stream_type=1</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.spi.spi_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode an SPI data stream</p>
<p>This is a generator function that can be used in a pipeline of waveform
processing operations.</p>
<p>The clk, data_io, and cs parameters are edge or sample streams.
Sample streams are a sequence of SampleChunk Objects. Edge streams are a sequence
of 2-tuples of (time, int) pairs. The type of stream is identified by the stream_type
parameter. Sample streams will be analyzed to find edge transitions representing
0 and 1 logic states of the waveforms. With sample streams, an initial block of data
on the clk stream is consumed to determine the most likely logic levels in the signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clk</strong> (<em>iterable of SampleChunk objects</em><em> or </em><em>(</em><em>float</em><em>, </em><em>int</em><em>) </em><em>pairs</em>) – A sample stream or edge stream representing an SPI clk signal</li>
<li><strong>data_io</strong> (<em>iterable of SampleChunk objects</em><em> or </em><em>(</em><em>float</em><em>, </em><em>int</em><em>) </em><em>pairs</em>) – A sample stream or edge stream representing an SPI MOSI or MISO signal.</li>
<li><strong>cs</strong> (<em>iterable of SampleChunk objects</em><em> or </em><em>(</em><em>float</em><em>, </em><em>int</em><em>) </em><em>pairs</em><em> or </em><em>None</em>) – A sample stream or edge stream representing an SPI chip select signal.
Can be None if cs is not available.</li>
<li><strong>cpol</strong> (<em>int</em>) – Clock polarity: 0 or 1 (the idle state of the clock signal)</li>
<li><strong>cpha</strong> (<em>int</em>) – Clock phase: 0 or 1 (data is sampled on the 1st clock edge (0) or the 2nd (1))</li>
<li><strong>lsb_first</strong> (<em>bool</em>) – Flag indicating whether the Least Significant Bit is transmitted first.</li>
<li><strong>logic_levels</strong> (<em>(</em><em>float</em><em>, </em><em>float</em><em>) or </em><em>None</em>) – Optional pair that indicates (low, high) logic levels of the sample
stream. When present, auto level detection is disabled. This has no effect on
edge streams.</li>
<li><strong>stream_type</strong> (<a class="reference internal" href="ripyl.html#ripyl.streaming.StreamType" title="ripyl.streaming.StreamType"><em>streaming.StreamType</em></a>) – A StreamType value indicating that the clk, data_io, and cs parameters represent either Samples
or Edges</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An iterator yielding  a series of SPIFrame objects.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">AutoLevelError if stream_type = Samples and the logic levels cannot
be determined.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.spi.spi_synth">
<code class="descclassname">ripyl.protocol.spi.</code><code class="descname">spi_synth</code><span class="sig-paren">(</span><em>data</em>, <em>word_size</em>, <em>clock_freq</em>, <em>cpol=0</em>, <em>cpha=0</em>, <em>lsb_first=True</em>, <em>idle_start=0.0</em>, <em>word_interval=0.0</em>, <em>idle_end=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.spi.spi_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate synthesized SPI waveform</p>
<p>This function simulates a transmission of data over SPI.</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>sequence of int</em>) – A sequence of words that will be transmitted serially</li>
<li><strong>word_size</strong> (<em>int</em>) – The number of bits in each word</li>
<li><strong>clock_freq</strong> (<em>float</em>) – The SPI clock frequency</li>
<li><strong>cpol</strong> (<em>int</em>) – Clock polarity: 0 or 1</li>
<li><strong>cpha</strong> (<em>int</em>) – Clock phase: 0 or 1</li>
<li><strong>lsb_first</strong> (<em>bool</em>) – Flag indicating whether the Least Significant Bit is transmitted first.</li>
<li><strong>idle_start</strong> (<em>float</em>) – The amount of idle time before the transmission of data begins</li>
<li><strong>word_interval</strong> (<em>float</em>) – The amount of time between data words</li>
<li><strong>idle_end</strong> (<em>float</em>) – The amount of idle time after the last transmission</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a triplet of pairs representing the three edge streams for clk, data_io, and cs
respectively. Each edge stream pair is in (time, value) format representing the
time and logic value (0 or 1) for each edge transition. The first set of pairs
yielded is the initial state of the waveforms.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.protocol.uart">
<span id="ripyl-protocol-uart-module"></span><h2>ripyl.protocol.uart module<a class="headerlink" href="#module-ripyl.protocol.uart" title="Permalink to this headline">¶</a></h2>
<p>UART protocol decoder</p>
<dl class="exception">
<dt id="ripyl.protocol.uart.AutoBaudError">
<em class="property">exception </em><code class="descclassname">ripyl.protocol.uart.</code><code class="descname">AutoBaudError</code><a class="headerlink" href="#ripyl.protocol.uart.AutoBaudError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamError" title="ripyl.streaming.StreamError"><code class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamError</span></code></a></p>
<p>Error for failed baud rate detection</p>
</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.uart.UARTConfig">
<em class="property">class </em><code class="descclassname">ripyl.protocol.uart.</code><code class="descname">UARTConfig</code><a class="headerlink" href="#ripyl.protocol.uart.UARTConfig" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><code class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></code></a></p>
<p>Enumeration of configuration settings</p>
<dl class="attribute">
<dt id="ripyl.protocol.uart.UARTConfig.IdleHigh">
<code class="descname">IdleHigh</code><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.uart.UARTConfig.IdleHigh" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.uart.UARTConfig.IdleLow">
<code class="descname">IdleLow</code><em class="property"> = 2</em><a class="headerlink" href="#ripyl.protocol.uart.UARTConfig.IdleLow" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.uart.UARTFrame">
<em class="property">class </em><code class="descclassname">ripyl.protocol.uart.</code><code class="descname">UARTFrame</code><span class="sig-paren">(</span><em>bounds</em>, <em>data=None</em>, <em>status=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.uart.UARTFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><code class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></code></a></p>
<p>Frame object for UART data</p>
<dl class="method">
<dt id="ripyl.protocol.uart.UARTFrame.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>bounds</em>, <em>data=None</em>, <em>status=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.uart.UARTFrame.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="ripyl.protocol.uart.UARTFrame.status_text">
<em class="property">classmethod </em><code class="descname">status_text</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.uart.UARTFrame.status_text" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.uart.UARTStreamStatus">
<em class="property">class </em><code class="descclassname">ripyl.protocol.uart.</code><code class="descname">UARTStreamStatus</code><a class="headerlink" href="#ripyl.protocol.uart.UARTStreamStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><code class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></code></a></p>
<p>Enumeration of UART status codes</p>
<dl class="attribute">
<dt id="ripyl.protocol.uart.UARTStreamStatus.FramingError">
<code class="descname">FramingError</code><em class="property"> = 201</em><a class="headerlink" href="#ripyl.protocol.uart.UARTStreamStatus.FramingError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.uart.UARTStreamStatus.ParityError">
<code class="descname">ParityError</code><em class="property"> = 202</em><a class="headerlink" href="#ripyl.protocol.uart.UARTStreamStatus.ParityError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.uart.uart_decode">
<code class="descclassname">ripyl.protocol.uart.</code><code class="descname">uart_decode</code><span class="sig-paren">(</span><em>stream_data</em>, <em>bits=8</em>, <em>parity=None</em>, <em>stop_bits=1.0</em>, <em>lsb_first=True</em>, <em>polarity=1</em>, <em>baud_rate=None</em>, <em>use_std_baud=True</em>, <em>logic_levels=None</em>, <em>stream_type=1</em>, <em>param_info=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.uart.uart_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode a UART data stream</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations.</p>
<p>Sample streams are a sequence of SampleChunk Objects. Edge streams are a sequence
of 2-tuples of (time, int) pairs. The type of stream is identified by the stream_type
parameter. Sample streams will be analyzed to find edge transitions representing
0 and 1 logic states of the waveforms. With sample streams, an initial block of data
is consumed to determine the most likely logic levels in the signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>stream_data</strong> (<em>iterable of SampleChunk objects</em><em> or </em><em>(</em><em>float</em><em>, </em><em>int</em><em>) </em><em>pairs</em>) – A sample stream or edge stream representing a serial data signal.</li>
<li><strong>bits</strong> (<em>int</em>) – The number of bits in each word. Typically 5, 7, 8, or 9.</li>
<li><strong>parity</strong> (<em>string</em><em> or </em><em>None</em>) – The type of parity to use. One of None, ‘even’, or ‘odd’</li>
<li><strong>stop_bits</strong> (<em>number</em>) – The number of stop bits. Typically 1, 1.5, or 2</li>
<li><strong>lsb_first</strong> (<em>bool</em>) – Flag indicating whether the Least Significant Bit is transmitted first.</li>
<li><strong>inverted</strong> (<em>bool</em>) – Flag indicating if the signal levels have been inverted from their logical
meaning. Use this when the input stream derives from an inverting driver such
as those used for RS-232.</li>
<li><strong>polarity</strong> (<a class="reference internal" href="#ripyl.protocol.uart.UARTConfig" title="ripyl.protocol.uart.UARTConfig"><em>UARTConfig</em></a>) – Set the polarity (idle state high or low).</li>
<li><strong>baud_rate</strong> (<em>int</em>) – The baud rate of the stream. If None, the first 50 edges will be analyzed to
automatically determine the most likely baud rate for the stream. On average
50 edges will occur after 11 frames have been captured.</li>
<li><strong>use_std_baud</strong> (<em>bool</em>) – Flag that forces coercion of automatically detected baud rate to the set of
standard rates</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param  :
:type logic_levels: (float, float) or None
:param logic_levels:</p>
<blockquote>
<div>Optional pair that indicates (low, high) logic levels of the sample
stream. When present, auto level detection is disabled. This has no effect on
edge streams.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>stream_type</strong> (<a class="reference internal" href="ripyl.html#ripyl.streaming.StreamType" title="ripyl.streaming.StreamType"><em>streaming.StreamType</em></a>) – A StreamType value indicating that the stream parameter represents either Samples
or Edges</td>
</tr>
</tbody>
</table>
<p>:param  :
:type param_info: dict or None
:param param_info:</p>
<blockquote>
<div>An optional dictionary object that is used to monitor the results of
automatic baud detection.</div></blockquote>
<p>:param  :
:returns: An iterator yielding  a series of UARTFrame objects. Each frame contains subrecords marking the location</p>
<blockquote>
<div>of sub-elements within the frame (start, data, parity, stop). Parity errors are recorded
as an error status in the parity subrecord. BRK conditions are reported as a data value
0x00 with a framing error in the status code.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">AutoLevelError if stream_type = Samples and the logic levels cannot
be determined.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">AutoBaudError if auto-baud is active and the baud rate cannot
be determined.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">ValueError if the parity argument is invalid.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.uart.uart_synth">
<code class="descclassname">ripyl.protocol.uart.</code><code class="descname">uart_synth</code><span class="sig-paren">(</span><em>data</em>, <em>bits=8</em>, <em>baud=115200</em>, <em>parity=None</em>, <em>stop_bits=1.0</em>, <em>idle_start=0.0</em>, <em>idle_end=0.0</em>, <em>word_interval=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.uart.uart_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate synthesized UART waveform</p>
<p>This function simulates a single, unidirectional channel of a UART serial
connection. Its output is analagous to txd. The signal is generated with
idle-high polarity.</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> (<em>sequence of int</em>) – A sequence of words that will be transmitted serially</li>
<li><strong>bits</strong> (<em>int</em>) – The number of bits in each word. Typically 5, 7, 8, or 9.</li>
<li><strong>baud</strong> (<em>int</em>) – The baud rate</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param  :
:type parity: string or None
:param parity:</p>
<blockquote>
<div>The type of parity to use. One of None, ‘even’, or ‘odd’</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>stop_bits</strong> (<em>number</em>) – The number of stop bits. Typically 1, 1.5, or 2</li>
<li><strong>idle_start</strong> (<em>float</em>) – The amount of idle time before the transmission of data begins</li>
<li><strong>idle_end</strong> (<em>float</em>) – The amount of idle time after the transmission of data ends</li>
<li><strong>word_interval</strong> (<em>float</em>) – The amount of time between data words</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a series of 2-tuples (time, value) representing the time and
logic value (0 or 1) for each edge transition on txd. The first tuple
yielded is the initial state of the waveform. All remaining
tuples are edges where the txd state changes.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.protocol.usb">
<span id="ripyl-protocol-usb-module"></span><h2>ripyl.protocol.usb module<a class="headerlink" href="#module-ripyl.protocol.usb" title="Permalink to this headline">¶</a></h2>
<p>USB protocol decoder</p>
<p>This Supports all of USB 2.0 including Low, Full, and High speed;
Link Power Management extended tokens; and USB 1.x mixed Low and
Full speed transmissions. HSIC protocol is also supported.</p>
<dl class="class">
<dt id="ripyl.protocol.usb.USBDataPacket">
<em class="property">class </em><code class="descclassname">ripyl.protocol.usb.</code><code class="descname">USBDataPacket</code><span class="sig-paren">(</span><em>pid</em>, <em>data</em>, <em>speed=1</em>, <em>delay=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBDataPacket" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.protocol.usb.USBPacket" title="ripyl.protocol.usb.USBPacket"><code class="xref py py-class docutils literal"><span class="pre">ripyl.protocol.usb.USBPacket</span></code></a></p>
<p>Data packet</p>
<dl class="method">
<dt id="ripyl.protocol.usb.USBDataPacket.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>pid</em>, <em>data</em>, <em>speed=1</em>, <em>delay=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBDataPacket.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBDataPacket.field_offsets">
<code class="descname">field_offsets</code><span class="sig-paren">(</span><em>with_stuffing=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBDataPacket.field_offsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dict of packet field bit offsets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>with_stuffing</strong> (<em>bool</em>) – Flag indicating whether to return fields adjusted for stuffed bits</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A dict keyed by the field name and a pair (start, end) for each value.
Start and end are the inclusive bit offsets for the start and end of a field
relative to the end of SOP.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBDataPacket.get_bits">
<code class="descname">get_bits</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBDataPacket.get_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate data packet bits</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBEXTPacket">
<em class="property">class </em><code class="descclassname">ripyl.protocol.usb.</code><code class="descname">USBEXTPacket</code><span class="sig-paren">(</span><em>pid</em>, <em>addr</em>, <em>endp</em>, <em>sub_pid</em>, <em>variable</em>, <em>speed=1</em>, <em>delay=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBEXTPacket" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.protocol.usb.USBPacket" title="ripyl.protocol.usb.USBPacket"><code class="xref py py-class docutils literal"><span class="pre">ripyl.protocol.usb.USBPacket</span></code></a></p>
<p>Extended packet</p>
<dl class="method">
<dt id="ripyl.protocol.usb.USBEXTPacket.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>pid</em>, <em>addr</em>, <em>endp</em>, <em>sub_pid</em>, <em>variable</em>, <em>speed=1</em>, <em>delay=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBEXTPacket.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBEXTPacket.field_offsets">
<code class="descname">field_offsets</code><span class="sig-paren">(</span><em>with_stuffing=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBEXTPacket.field_offsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dict of packet field bit offsets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>with_stuffing</strong> (<em>bool</em>) – Flag indicating whether to return fields adjusted for stuffed bits</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A dict keyed by the field name and a pair (start, end) for each value.
Start and end are the inclusive bit offsets for the start and end of a field
relative to the end of SOP.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBHandshakePacket">
<em class="property">class </em><code class="descclassname">ripyl.protocol.usb.</code><code class="descname">USBHandshakePacket</code><span class="sig-paren">(</span><em>pid</em>, <em>speed=1</em>, <em>delay=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBHandshakePacket" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.protocol.usb.USBPacket" title="ripyl.protocol.usb.USBPacket"><code class="xref py py-class docutils literal"><span class="pre">ripyl.protocol.usb.USBPacket</span></code></a></p>
<p>Handshake packet</p>
<dl class="method">
<dt id="ripyl.protocol.usb.USBHandshakePacket.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>pid</em>, <em>speed=1</em>, <em>delay=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBHandshakePacket.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBHandshakePacket.field_offsets">
<code class="descname">field_offsets</code><span class="sig-paren">(</span><em>with_stuffing=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBHandshakePacket.field_offsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dict of packet field bit offsets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>with_stuffing</strong> (<em>bool</em>) – Flag indicating whether to return fields adjusted for stuffed bits</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A dict keyed by the field name and a pair (start, end) for each value.
Start and end are the inclusive bit offsets for the start and end of a field
relative to the end of SOP.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBHandshakePacket.get_bits">
<code class="descname">get_bits</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBHandshakePacket.get_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate handshake packet bits</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBPID">
<em class="property">class </em><code class="descclassname">ripyl.protocol.usb.</code><code class="descname">USBPID</code><a class="headerlink" href="#ripyl.protocol.usb.USBPID" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><code class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></code></a></p>
<p>Enumeration for the packet PIDs</p>
<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.ACK">
<code class="descname">ACK</code><em class="property"> = 2</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.ACK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.Data0">
<code class="descname">Data0</code><em class="property"> = 3</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.Data0" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.Data1">
<code class="descname">Data1</code><em class="property"> = 11</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.Data1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.Data2">
<code class="descname">Data2</code><em class="property"> = 7</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.Data2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.ERR">
<code class="descname">ERR</code><em class="property"> = 12</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.ERR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.EXT">
<code class="descname">EXT</code><em class="property"> = 0</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.EXT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.MData">
<code class="descname">MData</code><em class="property"> = 15</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.MData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.NAK">
<code class="descname">NAK</code><em class="property"> = 10</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.NAK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.NYET">
<code class="descname">NYET</code><em class="property"> = 6</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.NYET" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.PING">
<code class="descname">PING</code><em class="property"> = 4</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.PING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.PRE">
<code class="descname">PRE</code><em class="property"> = 12</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.PRE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.SOF">
<code class="descname">SOF</code><em class="property"> = 5</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.SOF" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.SPLIT">
<code class="descname">SPLIT</code><em class="property"> = 8</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.SPLIT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.STALL">
<code class="descname">STALL</code><em class="property"> = 14</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.STALL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.TokenIn">
<code class="descname">TokenIn</code><em class="property"> = 9</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.TokenIn" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.TokenOut">
<code class="descname">TokenOut</code><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.TokenOut" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.TokenSetup">
<code class="descname">TokenSetup</code><em class="property"> = 13</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.TokenSetup" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBPacket">
<em class="property">class </em><code class="descclassname">ripyl.protocol.usb.</code><code class="descname">USBPacket</code><span class="sig-paren">(</span><em>pid</em>, <em>speed=1</em>, <em>delay=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBPacket" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Base class for USB packet objects</p>
<p>This class should not be instanced directly. Use the various subclasses instead.</p>
<p>These objects have methods meant to be used by the usb_synth() routine. When
these objects are embedded in a USBStreamPacket object they are used for attribute
access only.</p>
<dl class="method">
<dt id="ripyl.protocol.usb.USBPacket.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>pid</em>, <em>speed=1</em>, <em>delay=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBPacket.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBPacket.field_offsets">
<code class="descname">field_offsets</code><span class="sig-paren">(</span><em>with_stuffing=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBPacket.field_offsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dict of packet field bit offsets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A dict keyed by the field name and a pair (start, end) for each value.
Start and end are the inclusive bit offsets for the start and end of a field
relative to the end of SOP.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBPacket.get_bits">
<code class="descname">get_bits</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBPacket.get_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the raw data bits of a packet in LSB-first order</p>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBPacket.get_diff_edges">
<code class="descname">get_diff_edges</code><span class="sig-paren">(</span><em>cur_time=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBPacket.get_diff_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Produce a set of edges corresponding to USB differential (D+ - D-) signal</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cur_time</strong> (<em>float</em>) – The starting offset time for the edges</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of differential edges</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBPacket.get_edges">
<code class="descname">get_edges</code><span class="sig-paren">(</span><em>cur_time=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBPacket.get_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Produce a set of edges corresponding to USB D+ and D- signals</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cur_time</strong> (<em>float</em>) – The starting offset time for the edges</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A 2-tuple containing the d+ and d- edge lists</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBPacket.get_hsic_edges">
<code class="descname">get_hsic_edges</code><span class="sig-paren">(</span><em>cur_time=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBPacket.get_hsic_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Produce a set of edges corresponding to USB HSIC (strobe, data) signals</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cur_time</strong> (<em>float</em>) – The starting offset time for the edges</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A 2-tuple containing the strobe and data edge lists</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBPacket.sop_bits">
<code class="descname">sop_bits</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBPacket.sop_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of SOP bits in packet</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBPacketKind">
<em class="property">class </em><code class="descclassname">ripyl.protocol.usb.</code><code class="descname">USBPacketKind</code><a class="headerlink" href="#ripyl.protocol.usb.USBPacketKind" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><code class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></code></a></p>
<p>Enumeration for packet kind (lower two bits of PID)</p>
<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPacketKind.Data">
<code class="descname">Data</code><em class="property"> = 3</em><a class="headerlink" href="#ripyl.protocol.usb.USBPacketKind.Data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPacketKind.Handshake">
<code class="descname">Handshake</code><em class="property"> = 2</em><a class="headerlink" href="#ripyl.protocol.usb.USBPacketKind.Handshake" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPacketKind.Special">
<code class="descname">Special</code><em class="property"> = 0</em><a class="headerlink" href="#ripyl.protocol.usb.USBPacketKind.Special" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPacketKind.Token">
<code class="descname">Token</code><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.usb.USBPacketKind.Token" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBSOFPacket">
<em class="property">class </em><code class="descclassname">ripyl.protocol.usb.</code><code class="descname">USBSOFPacket</code><span class="sig-paren">(</span><em>pid</em>, <em>frame_num</em>, <em>speed=1</em>, <em>delay=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBSOFPacket" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.protocol.usb.USBPacket" title="ripyl.protocol.usb.USBPacket"><code class="xref py py-class docutils literal"><span class="pre">ripyl.protocol.usb.USBPacket</span></code></a></p>
<p>Start of Frame packet</p>
<dl class="method">
<dt id="ripyl.protocol.usb.USBSOFPacket.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>pid</em>, <em>frame_num</em>, <em>speed=1</em>, <em>delay=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBSOFPacket.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBSOFPacket.field_offsets">
<code class="descname">field_offsets</code><span class="sig-paren">(</span><em>with_stuffing=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBSOFPacket.field_offsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dict of packet field bit offsets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>with_stuffing</strong> (<em>bool</em>) – Flag indicating whether to return fields adjusted for stuffed bits</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A dict keyed by the field name and a pair (start, end) for each value.
Start and end are the inclusive bit offsets for the start and end of a field
relative to the end of SOP.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBSOFPacket.get_bits">
<code class="descname">get_bits</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBSOFPacket.get_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate SOF packet bits</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBSpeed">
<em class="property">class </em><code class="descclassname">ripyl.protocol.usb.</code><code class="descname">USBSpeed</code><a class="headerlink" href="#ripyl.protocol.usb.USBSpeed" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><code class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></code></a></p>
<p>Enumeration for the USB bus speeds</p>
<dl class="attribute">
<dt id="ripyl.protocol.usb.USBSpeed.FullSpeed">
<code class="descname">FullSpeed</code><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.usb.USBSpeed.FullSpeed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBSpeed.HighSpeed">
<code class="descname">HighSpeed</code><em class="property"> = 2</em><a class="headerlink" href="#ripyl.protocol.usb.USBSpeed.HighSpeed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBSpeed.LowSpeed">
<code class="descname">LowSpeed</code><em class="property"> = 0</em><a class="headerlink" href="#ripyl.protocol.usb.USBSpeed.LowSpeed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBSplitPacket">
<em class="property">class </em><code class="descclassname">ripyl.protocol.usb.</code><code class="descname">USBSplitPacket</code><span class="sig-paren">(</span><em>pid</em>, <em>addr</em>, <em>sc</em>, <em>port</em>, <em>s</em>, <em>e</em>, <em>et</em>, <em>speed=2</em>, <em>delay=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBSplitPacket" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.protocol.usb.USBPacket" title="ripyl.protocol.usb.USBPacket"><code class="xref py py-class docutils literal"><span class="pre">ripyl.protocol.usb.USBPacket</span></code></a></p>
<p>Split packet</p>
<dl class="method">
<dt id="ripyl.protocol.usb.USBSplitPacket.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>pid</em>, <em>addr</em>, <em>sc</em>, <em>port</em>, <em>s</em>, <em>e</em>, <em>et</em>, <em>speed=2</em>, <em>delay=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBSplitPacket.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBSplitPacket.field_offsets">
<code class="descname">field_offsets</code><span class="sig-paren">(</span><em>with_stuffing=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBSplitPacket.field_offsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dict of packet field bit offsets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>with_stuffing</strong> (<em>bool</em>) – Flag indicating whether to return fields adjusted for stuffed bits</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A dict keyed by the field name and a pair (start, end) for each value.
Start and end are the inclusive bit offsets for the start and end of a field
relative to the end of SOP.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBSplitPacket.get_bits">
<code class="descname">get_bits</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBSplitPacket.get_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate split packet bits</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBState">
<em class="property">class </em><code class="descclassname">ripyl.protocol.usb.</code><code class="descname">USBState</code><a class="headerlink" href="#ripyl.protocol.usb.USBState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><code class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></code></a></p>
<p>Enumeration for logical bus states</p>
<dl class="attribute">
<dt id="ripyl.protocol.usb.USBState.J">
<code class="descname">J</code><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.usb.USBState.J" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBState.K">
<code class="descname">K</code><em class="property"> = 2</em><a class="headerlink" href="#ripyl.protocol.usb.USBState.K" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBState.SE0">
<code class="descname">SE0</code><em class="property"> = 0</em><a class="headerlink" href="#ripyl.protocol.usb.USBState.SE0" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBState.SE1">
<code class="descname">SE1</code><em class="property"> = 3</em><a class="headerlink" href="#ripyl.protocol.usb.USBState.SE1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBStreamError">
<em class="property">class </em><code class="descclassname">ripyl.protocol.usb.</code><code class="descname">USBStreamError</code><span class="sig-paren">(</span><em>bounds</em>, <em>error_data</em>, <em>pid=-1</em>, <em>status=200</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBStreamError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><code class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></code></a></p>
<p>Contains partially decoded packet data after an error has been found
in the data stream</p>
<dl class="method">
<dt id="ripyl.protocol.usb.USBStreamError.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>bounds</em>, <em>error_data</em>, <em>pid=-1</em>, <em>status=200</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBStreamError.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>bounds</strong> (<em>(</em><em>float</em><em>, </em><em>float</em><em>)</em>) – 2-tuple (start_time, end_time) for the packet</td>
</tr>
</tbody>
</table>
<p>:param  :
:type error_data: sequence of int
:param error_data:</p>
<blockquote>
<div>An array of bits (potentially unstuffed) for the packet</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pid</strong> (<em>int</em>) – The PID for the packet if it was successfully extracted. -1 if the
PID was invalid or unavailable.</li>
<li><strong>status</strong> (<em>int</em>) – Status code for the packet</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBStreamPacket">
<em class="property">class </em><code class="descclassname">ripyl.protocol.usb.</code><code class="descname">USBStreamPacket</code><span class="sig-paren">(</span><em>bounds</em>, <em>sop_end</em>, <em>packet</em>, <em>crc=None</em>, <em>status=0</em>, <em>sop_end2=None</em>, <em>crc2=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBStreamPacket" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><code class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></code></a></p>
<p>Encapsulates a USBPacket object (see below) into a StreamSegment</p>
<dl class="method">
<dt id="ripyl.protocol.usb.USBStreamPacket.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>bounds</em>, <em>sop_end</em>, <em>packet</em>, <em>crc=None</em>, <em>status=0</em>, <em>sop_end2=None</em>, <em>crc2=None</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBStreamPacket.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>bounds</strong> (<em>(</em><em>float</em><em>, </em><em>float</em><em>)</em>) – 2-tuple (start_time, end_time) for the packet</td>
</tr>
</tbody>
</table>
<p>:param  :
:type sop_end: float
:param sop_end:</p>
<blockquote>
<div>The time for the end of the SOP portion of the packet. Used to measure
bit positions for the packet fields.</div></blockquote>
<p>:param  :
:type packet: USBPacket
:param packet:</p>
<blockquote>
<div>USBPacket object to encapsulate</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>crc</strong> (<em>int</em><em> or </em><em>None</em>) – Optional CRC extracted from a decoded packet. Not used for encoding
with usb_synth().</td>
</tr>
</tbody>
</table>
<p>:param  :
:type status: int
:param status:</p>
<blockquote>
<div>Status code for the packet</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sop_end2</strong> (<em>float</em><em> or </em><em>None</em>) – The time for the end of the second SOP in an EXT packet</li>
<li><strong>crc2</strong> (<em>int</em><em> or </em><em>None</em>) – Optional CRC from second part of EXT packet</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBStreamPacket.field_offsets">
<code class="descname">field_offsets</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBStreamPacket.field_offsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dict of packet field bit offsets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A dict keyed by the field name and a pair (start, end) for each value.
Start and end are the inclusive times for the start and end of a field.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBStreamPacket.packet">
<code class="descname">packet</code><a class="headerlink" href="#ripyl.protocol.usb.USBStreamPacket.packet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="ripyl.protocol.usb.USBStreamPacket.status_text">
<em class="property">classmethod </em><code class="descname">status_text</code><span class="sig-paren">(</span><em>status</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBStreamPacket.status_text" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBStreamStatus">
<em class="property">class </em><code class="descclassname">ripyl.protocol.usb.</code><code class="descname">USBStreamStatus</code><a class="headerlink" href="#ripyl.protocol.usb.USBStreamStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><code class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></code></a></p>
<p>Enumeration for USBStreamPacket and USBStreamError status codes</p>
<dl class="attribute">
<dt id="ripyl.protocol.usb.USBStreamStatus.BitStuffingError">
<code class="descname">BitStuffingError</code><em class="property"> = 203</em><a class="headerlink" href="#ripyl.protocol.usb.USBStreamStatus.BitStuffingError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBStreamStatus.CRCError">
<code class="descname">CRCError</code><em class="property"> = 204</em><a class="headerlink" href="#ripyl.protocol.usb.USBStreamStatus.CRCError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBStreamStatus.MissingEOPError">
<code class="descname">MissingEOPError</code><em class="property"> = 202</em><a class="headerlink" href="#ripyl.protocol.usb.USBStreamStatus.MissingEOPError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBStreamStatus.ShortPacketError">
<code class="descname">ShortPacketError</code><em class="property"> = 201</em><a class="headerlink" href="#ripyl.protocol.usb.USBStreamStatus.ShortPacketError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBTokenPacket">
<em class="property">class </em><code class="descclassname">ripyl.protocol.usb.</code><code class="descname">USBTokenPacket</code><span class="sig-paren">(</span><em>pid</em>, <em>addr</em>, <em>endp</em>, <em>speed=1</em>, <em>delay=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBTokenPacket" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.protocol.usb.USBPacket" title="ripyl.protocol.usb.USBPacket"><code class="xref py py-class docutils literal"><span class="pre">ripyl.protocol.usb.USBPacket</span></code></a></p>
<p>Token packet</p>
<dl class="method">
<dt id="ripyl.protocol.usb.USBTokenPacket.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>pid</em>, <em>addr</em>, <em>endp</em>, <em>speed=1</em>, <em>delay=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBTokenPacket.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBTokenPacket.field_offsets">
<code class="descname">field_offsets</code><span class="sig-paren">(</span><em>with_stuffing=False</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBTokenPacket.field_offsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dict of packet field bit offsets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>with_stuffing</strong> (<em>bool</em>) – Flag indicating whether to return fields adjusted for stuffed bits</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A dict keyed by the field name and a pair (start, end) for each value.
Start and end are the inclusive bit offsets for the start and end of a field
relative to the end of SOP.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBTokenPacket.get_bits">
<code class="descname">get_bits</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.USBTokenPacket.get_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate token packet bits</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.usb.table_usb_crc16">
<code class="descclassname">ripyl.protocol.usb.</code><code class="descname">table_usb_crc16</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.table_usb_crc16" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate USB CRC-16 on data</p>
<p>This is a table-based byte-wise implementation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>d</strong> (<em>sequence of int</em>) – Array of integers representing bytes</td>
</tr>
</tbody>
</table>
<p>:param  :
:returns: Array of integers for each bit in the crc with lsb first</p>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.usb.usb_crc16">
<code class="descclassname">ripyl.protocol.usb.</code><code class="descname">usb_crc16</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.usb_crc16" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate USB CRC-16 on data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>d</strong> (<em>sequence of int</em>) – Array of integers representing 0 or 1 bits in transmission order</td>
</tr>
</tbody>
</table>
<p>:param  :
:returns: Array of integers for each bit in the crc with lsb first</p>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.usb.usb_crc5">
<code class="descclassname">ripyl.protocol.usb.</code><code class="descname">usb_crc5</code><span class="sig-paren">(</span><em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.usb_crc5" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate USB CRC-5 on data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>d</strong> (<em>sequence of int</em>) – Array of integers representing 0 or 1 bits in transmission order</td>
</tr>
</tbody>
</table>
<p>:param  :
:returns: Array of integers for each bit in the crc with lsb first</p>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.usb.usb_decode">
<code class="descclassname">ripyl.protocol.usb.</code><code class="descname">usb_decode</code><span class="sig-paren">(</span><em>dp</em>, <em>dm</em>, <em>logic_levels=None</em>, <em>stream_type=1</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.usb_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode a USB data stream</p>
<p>This is a generator function that can be used in a pipeline of waveform
processing operations.</p>
<p>This function decodes USB data captured from the two single-ended D+ and D- signals.
For differential USB decode see the function usb_diff_decode().</p>
<p>Low speed device keep-alive EOPs are not reported in the decoded results.</p>
<p>The dp and dm parameters are edge or sample streams.
Sample streams are a sequence of SampleChunk Objects. Edge streams are a sequence
of 2-tuples of (time, int) pairs. The type of stream is identified by the stream_type
parameter. Sample streams will be analyzed to find edge transitions representing
0 and 1 logic states of the waveforms. With sample streams, an initial block of data
on the dp stream is consumed to determine the most likely logic levels in the signal
and the bus speed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dp</strong> (<em>iterable of SampleChunk objects</em><em> or </em><em>(</em><em>float</em><em>, </em><em>int</em><em>) </em><em>pairs</em>) – A sample stream or edge stream representing a USB D+ signal</li>
<li><strong>dm</strong> (<em>iterable of SampleChunk objects</em><em> or </em><em>(</em><em>float</em><em>, </em><em>int</em><em>) </em><em>pairs</em>) – A sample stream or edge stream representing a USB D- signal</li>
<li><strong>logic_levels</strong> (<em>(</em><em>float</em><em>, </em><em>float</em><em>) or </em><em>None</em>) – Optional pair that indicates (low, high) logic levels of the sample
stream. When present, auto level detection is disabled. This has no effect on
edge streams.</li>
<li><strong>stream_type</strong> (<a class="reference internal" href="ripyl.html#ripyl.streaming.StreamType" title="ripyl.streaming.StreamType"><em>streaming.StreamType</em></a>) – A StreamType value indicating that the dp, and dm parameters represent either Samples
or Edges</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param  :
:returns: An iterator yielding  a series of USBStreamPacket and USBStreamError objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">AutoLevelError if stream_type = Samples and the logic levels cannot
be determined.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">StreamError if the bus speed cannot be determined.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.usb.usb_diff_decode">
<code class="descclassname">ripyl.protocol.usb.</code><code class="descname">usb_diff_decode</code><span class="sig-paren">(</span><em>d_diff</em>, <em>logic_levels=None</em>, <em>stream_type=1</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.usb_diff_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode a differential USB data stream</p>
<p>This is a generator function that can be used in a pipeline of waveform
processing operations.</p>
<p>This function decodes USB data captured from a differential (D+)-(D-) signal.
For single-ended USB decode see the function usb_decode().</p>
<p>Low speed device keep-alive EOPs are not reported in the decoded results.</p>
<p>The d_diff parameter is an edge or sample stream.
Sample streams are a sequence of SampleChunk Objects. Edge streams are a sequence
of 2-tuples of (time, int) pairs. The type of stream is identified by the stream_type
parameter. Sample streams will be analyzed to find edge transitions representing
0 and 1 logic states of the waveforms. With sample streams, an initial block of data
is consumed to determine the most likely logic levels in the signal and the bus speed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>d_diff</strong> (<em>iterable of SampleChunk objects</em><em> or </em><em>(</em><em>float</em><em>, </em><em>int</em><em>) </em><em>pairs</em>) – A sample stream or edge stream representing a USB differential (D+ - D-) signal.</li>
<li><strong>logic_levels</strong> (<em>(</em><em>float</em><em>, </em><em>float</em><em>) or </em><em>None</em>) – Optional pair that indicates (low, high) logic levels of the sample
stream. When present, auto level detection is disabled. This has no effect on
edge streams.</li>
<li><strong>stream_type</strong> (<a class="reference internal" href="ripyl.html#ripyl.streaming.StreamType" title="ripyl.streaming.StreamType"><em>streaming.StreamType</em></a>) – A StreamType value indicating that the dp, and dm parameters represent either Samples
or Edges</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param  :
:returns: An iterator yielding  a series of USBStreamPacket and USBStreamError objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">AutoLevelError if stream_type = Samples and the logic levels cannot
be determined.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">StreamError if the bus speed cannot be determined.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.usb.usb_diff_synth">
<code class="descclassname">ripyl.protocol.usb.</code><code class="descname">usb_diff_synth</code><span class="sig-paren">(</span><em>packets</em>, <em>idle_start=0.0</em>, <em>idle_end=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.usb_diff_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate synthesized differential USB waveforms</p>
<p>This function simulates USB packet transmission on the differential D+ - D-
signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>packets</strong> (<em>sequence of USBPacket</em>) – The packet objects that are to be simulated</li>
<li><strong>idle_start</strong> (<em>float</em>) – The amount of idle time before the transmission of packets begins</li>
<li><strong>idle_end</strong> (<em>float</em>) – The amount of idle time after the last packet</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator of 2-tuples for the d+ - d- differential channel. each
2-tuple is a (time, value) pair representing the time and the
logic value (-1, 0, or 1) for each edge transition. The first tuple
yielded is the initial state of the waveform. All remaining tuples are
edges where the state changes.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.usb.usb_hsic_decode">
<code class="descclassname">ripyl.protocol.usb.</code><code class="descname">usb_hsic_decode</code><span class="sig-paren">(</span><em>strobe</em>, <em>data</em>, <em>logic_levels=None</em>, <em>stream_type=1</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.usb_hsic_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode a USB HSIC data stream</p>
<p>This is a generator function that can be used in a pipeline of waveform
processing operations.</p>
<p>This function decodes USB HSIC data captured from the two single-ended strobe and data
signals.</p>
<p>The strobe and data parameters are edge or sample streams.
Sample streams are a sequence of SampleChunk Objects. Edge streams are a sequence
of 2-tuples of (time, int) pairs. The type of stream is identified by the stream_type
parameter. Sample streams will be analyzed to find edge transitions representing
0 and 1 logic states of the waveforms. With sample streams, an initial block of data
on the strobe stream is consumed to determine the most likely logic levels in the signal.</p>
<p>The bus speed is fixed at 480Mb/s.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>strobe</strong> (<em>iterable of SampleChunk objects</em><em> or </em><em>(</em><em>float</em><em>, </em><em>int</em><em>) </em><em>pairs</em>) – A sample stream or edge stream representing an HSIC strobe signal</li>
<li><strong>data</strong> (<em>iterable of SampleChunk objects</em><em> or </em><em>(</em><em>float</em><em>, </em><em>int</em><em>) </em><em>pairs</em>) – A sample stream or edge stream representing an HSIC data signal</li>
<li><strong>logic_levels</strong> (<em>(</em><em>float</em><em>, </em><em>float</em><em>) or </em><em>None</em>) – Optional pair that indicates (low, high) logic levels of the sample
stream. When present, auto level detection is disabled. This has no effect on
edge streams.</li>
<li><strong>stream_type</strong> (<a class="reference internal" href="ripyl.html#ripyl.streaming.StreamType" title="ripyl.streaming.StreamType"><em>streaming.StreamType</em></a>) – A StreamType value indicating that the strobe, and data parameters represent either Samples
or Edges</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>:param  :
:returns: An iterator yielding  a series of USBStreamPacket and USBStreamError objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">AutoLevelError if stream_type = Samples and the logic levels cannot
be determined.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.usb.usb_hsic_synth">
<code class="descclassname">ripyl.protocol.usb.</code><code class="descname">usb_hsic_synth</code><span class="sig-paren">(</span><em>packets</em>, <em>idle_start=0.0</em>, <em>idle_end=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.usb_hsic_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate synthesized USB HSIC waveforms</p>
<p>This function simulates USB packet transmission on the HSIC strobe and data signals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>packets</strong> (<em>sequence of USBPacket</em>) – The packet objects that are to be simulated</li>
<li><strong>idle_start</strong> (<em>float</em>) – The amount of idle time before the transmission of packets begins</li>
<li><strong>idle_end</strong> (<em>float</em>) – The amount of idle time after the last packet</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A pair of iterators (strobe, data) for the strobe and data channels. each
iterator is a 2-tuple (time, value) representing the time and the
logic value (0 or 1) for each edge transition on strobe and data. The first tuple
yielded is the initial state of the waveform. All remaining tuples are
edges where the state changes.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.usb.usb_synth">
<code class="descclassname">ripyl.protocol.usb.</code><code class="descname">usb_synth</code><span class="sig-paren">(</span><em>packets</em>, <em>idle_start=0.0</em>, <em>idle_end=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb.usb_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate synthesized USB waveforms</p>
<p>This function simulates USB packet transmission on the D+ and D- signals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>packets</strong> (<em>sequence of USBPacket</em>) – The packet objects that are to be simulated</li>
<li><strong>idle_start</strong> (<em>float</em>) – The amount of idle time before the transmission of packets begins</li>
<li><strong>idle_end</strong> (<em>float</em>) – The amount of idle time after the last packet</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A pair of iterators (dp, dm) for the d+ and d- channels. each
iterator is a 2-tuple (time, value) representing the time and the
logic value (0 or 1) for each edge transition on D+ and D-. The first tuple
yielded is the initial state of the waveform. All remaining tuples are
edges where the state changes.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.protocol.usb_transact">
<span id="ripyl-protocol-usb-transact-module"></span><h2>ripyl.protocol.usb_transact module<a class="headerlink" href="#module-ripyl.protocol.usb_transact" title="Permalink to this headline">¶</a></h2>
<p>USB transaction decoder</p>
<p>Processes a USB packet stream into a set of USBTransaction objects</p>
<dl class="class">
<dt id="ripyl.protocol.usb_transact.USBTransaction">
<em class="property">class </em><code class="descclassname">ripyl.protocol.usb_transact.</code><code class="descname">USBTransaction</code><span class="sig-paren">(</span><em>packets</em>, <em>status=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb_transact.USBTransaction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamRecord" title="ripyl.streaming.StreamRecord"><code class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamRecord</span></code></a></p>
<p>Collection of packets forming a USB transaction</p>
<p>The ‘subrecords’ attribute is aliased to the ‘packets’ attribute.
These “packets” are USBStreamPacket objects rather than unadorned
USBPacket objects.</p>
<dl class="method">
<dt id="ripyl.protocol.usb_transact.USBTransaction.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>packets</em>, <em>status=0</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb_transact.USBTransaction.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>packets</strong> (<a class="reference internal" href="#ripyl.protocol.usb.USBStreamPacket" title="ripyl.protocol.usb.USBStreamPacket"><em>USBStreamPacket</em></a>) – A sequence of packet objects in the transaction</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb_transact.USBTransaction.end_time">
<code class="descname">end_time</code><a class="headerlink" href="#ripyl.protocol.usb_transact.USBTransaction.end_time" title="Permalink to this definition">¶</a></dt>
<dd><p>The end time of the last packet</p>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb_transact.USBTransaction.packets">
<code class="descname">packets</code><a class="headerlink" href="#ripyl.protocol.usb_transact.USBTransaction.packets" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of USBStreamPacket objects from this transaction</p>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb_transact.USBTransaction.start_time">
<code class="descname">start_time</code><a class="headerlink" href="#ripyl.protocol.usb_transact.USBTransaction.start_time" title="Permalink to this definition">¶</a></dt>
<dd><p>The start time of the first packet</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.usb_transact.extract_transaction_packets">
<code class="descclassname">ripyl.protocol.usb_transact.</code><code class="descname">extract_transaction_packets</code><span class="sig-paren">(</span><em>records</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb_transact.extract_transaction_packets" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a stream of USB transactions into raw USBPacket objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>records</strong> (<em>sequence of USBTransaction</em>) – Iterator of USBTransaction objects</td>
</tr>
</tbody>
</table>
<p>:param  :
:returns: An iterator yielding  a stream of USBPacket objects</p>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.usb_transact.usb_transactions_decode">
<code class="descclassname">ripyl.protocol.usb_transact.</code><code class="descname">usb_transactions_decode</code><span class="sig-paren">(</span><em>records</em><span class="sig-paren">)</span><a class="headerlink" href="#ripyl.protocol.usb_transact.usb_transactions_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a stream of USB packets into transactions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>records</strong> (<em>sequence of USBPacket</em>) – An iterator containing USBPacket objects as produced by usb.usb_decode()</td>
</tr>
</tbody>
</table>
<p>:param  :
:returns: An iterator yielding  a stream of USBTransaction objects containing packets merged into identifiable</p>
<blockquote>
<div>transactions. Any non-USBPacket objects in the input stream will also be present as
will SOF packets.</div></blockquote>
</dd></dl>

</div>
<div class="section" id="module-ripyl.protocol">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-ripyl.protocol" title="Permalink to this headline">¶</a></h2>
<p>Protocol package</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/Ripyl_logo_100px.png" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">Ripyl</a></h1>



<p class="blurb">Protocol decode and synthesis library</p>



<p>
<iframe src="https://ghbtns.com/github-btn.html?user=kevinpt&repo=ripyl&type=watch&count=true&size=large"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>


<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="modules.html">ripyl</a><ul>
  <li><a href="ripyl.html">ripyl package</a><ul>
      <li>Previous: <a href="ripyl.io.html" title="previous chapter">ripyl.io package</a></li>
      <li>Next: <a href="ripyl.protocol.infrared.html" title="next chapter">ripyl.protocol.infrared package</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">ripyl.protocol package</a><ul>
<li><a class="reference internal" href="#subpackages">Subpackages</a></li>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-ripyl.protocol.can">ripyl.protocol.can module</a></li>
<li><a class="reference internal" href="#module-ripyl.protocol.ethernet">ripyl.protocol.ethernet module</a></li>
<li><a class="reference internal" href="#module-ripyl.protocol.i2c">ripyl.protocol.i2c module</a></li>
<li><a class="reference internal" href="#module-ripyl.protocol.i2s">ripyl.protocol.i2s module</a></li>
<li><a class="reference internal" href="#module-ripyl.protocol.iso_k_line">ripyl.protocol.iso_k_line module</a></li>
<li><a class="reference internal" href="#module-ripyl.protocol.j1850">ripyl.protocol.j1850 module</a></li>
<li><a class="reference internal" href="#module-ripyl.protocol.lin">ripyl.protocol.lin module</a></li>
<li><a class="reference internal" href="#module-ripyl.protocol.lm73">ripyl.protocol.lm73 module</a></li>
<li><a class="reference internal" href="#module-ripyl.protocol.obd2">ripyl.protocol.obd2 module</a></li>
<li><a class="reference internal" href="#module-ripyl.protocol.ps2">ripyl.protocol.ps2 module</a></li>
<li><a class="reference internal" href="#module-ripyl.protocol.sagem_ecu">ripyl.protocol.sagem_ecu module</a></li>
<li><a class="reference internal" href="#module-ripyl.protocol.spi">ripyl.protocol.spi module</a></li>
<li><a class="reference internal" href="#module-ripyl.protocol.uart">ripyl.protocol.uart module</a></li>
<li><a class="reference internal" href="#module-ripyl.protocol.usb">ripyl.protocol.usb module</a></li>
<li><a class="reference internal" href="#module-ripyl.protocol.usb_transact">ripyl.protocol.usb_transact module</a></li>
<li><a class="reference internal" href="#module-ripyl.protocol">Module contents</a></li>
</ul>
</li>
</ul>
<h3>Other projects</h3>

<div id="proj_list">
<p>
<a href="http://kevinpt.github.io/opbasm/">Opbasm</a><br>

<a href="http://code.google.com/p/vertcl">Vertcl</a><br>
<a href="http://code.google.com/p/vhdl-extras">Vhdl-extras</a><br>
<a href="http://kevinpt.github.io/lecroy-colorizer/">Lecroy-colorizer</a>
</p>
</div>

<script>
$(function() { // Retrieve list of repositories from Github and dynamically insert them into sidebar

if(!window.sessionStorage || !JSON) { return; } // Punt on crusty browsers (looking at you IE10)

function JSONP( url, callback ) {
	var id = ( 'jsonp' + Math.random() * new Date() ).replace('.', '');
	var script = document.createElement('script');
	script.src = url.replace( 'callback=?', 'callback=' + id );
	document.body.appendChild( script );
	window[ id ] = function( data ) {
		if (callback) {
			callback( data );
		}
	};
}

function insert_projects(projects) {
    var links = [];
    var cur_proj = "Ripyl".toLowerCase();
    $.each(projects, function(key, value) {
      if(key != cur_proj) {
        var title = key.replace(/^./, function(match) {return match.toUpperCase()}); // Capitalize first char
        links.push("<a href='"+ value +"'>" + title + "</a>");
      }
    });
    
    $("#proj_list").html("<p>"+ links.join("<br>") +"</p>");
}

var now = new Date().getTime();
if(sessionStorage.KTcacheTime && now - sessionStorage.KTcacheTime < 5*60*1000 ) { // Use cached values (5 min. expiry)
  insert_projects(JSON.parse(sessionStorage.KTprojects));
} else { // Retrieve current projects
  JSONP("https://api.github.com/users/kevinpt/repos?type=owner&callback=?", function(response) {
    var projects = {};
    $.each(response.data, function(index, value) {
      projects[value.name] = value.homepage;
    });
    
    insert_projects(projects);
    
    // Store data in session cache
    sessionStorage.KTprojects = JSON.stringify(projects);
    var now = new Date().getTime();
    sessionStorage.KTcacheTime = now;
  });  
}

});
</script>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>

    <div class="footer">
      &copy;2015, Kevin Thibedeau.
      
      |
      <a href="../_sources/apidoc/ripyl.protocol.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-43149311-1', 'auto');
  ga('send', 'pageview');

</script>

  </body>
</html>